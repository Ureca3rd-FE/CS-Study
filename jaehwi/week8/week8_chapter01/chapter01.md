# 인덱스 (Index)

[Index | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/data-base/Index-.html)

**<목차>**

---

# **인덱스(Index)란?**

## 인덱스(Index)의 개념

<aside>
💡

데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조

</aside>

테이블의 특정 컬럼(Column)에 인덱스를 생성

  → 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 저장됨 = `(key, value)` 형태

`(key, value)` = (컬럼 값, 물리 주소)

인덱스를 간단히 말하면, 특정 컬럼을 복사하여 정렬한 컬럼의 **복사본**

*ex) 인덱스 = 책의 목차…*

```
책의 내용 = 데이터
책의 목차 = 인덱스
책의 페이지 번호 = 물리적주소
```

## 인덱스(Index)의 목적

> 목적 = RDBMS에서 검색 속도를 높이기 위해 사용하는 기술
> 

Table의 **Column을 색인화** (= 따로 파일로 저장)

→ 해당 Table의 Record를 Full scan 하지 않음

→ 색인화된 (B+ Tree 구조) Index 파일 검색으로 인한 검색 속도 향상

## 인덱스(Index)의 과정

> Index를 해당 컬럼에 주게 된다면? 초기 Table을 생성 → **MYD, MYI, FRM** 3개의 파일이 생성
> 

- **FRM** : 테이블 구조가 저장되어 있는 파일
- **MYD** : 실제 데이터가 있는 파일
- **MYI** : Index 정보가 들어있는 파일

Index를 사용하지 않는 경우 → MYI 파일이 비어있음

그러나 Index를 해당 컬럼에 만든다면, 해당 컬럼을 따로 인덱싱하여 MYI파일에 입력 = MYI 생성

**이후에 사용자가 Select 쿼리로** Index를 사용하는 컬럼 탐색 시, **MYI 파일**의 내용을 검색

# **인덱스**(**Index)의 자료 구조**

## **1. 해시 테이블(Hash Table)**

> **key와 value를 한 쌍으로 하여 `(key, value)` 형태로 데이터를 저장하는 자료구조**
> 
> 
>   → key값을 이용해 대응되는 value값을 구하는 방식
> 

- 해시 충돌이 있을 수 있지만, 평균적으로 **O(1)**의 매우 빠른 시간만에 원하는 데이터를 탐색 가능
- 인덱스가 **`(key, value) = (컬럼의 값, 데이터의 위치)`** 형태로 구현됨
- 그러나 실제로 인덱스에서는 사용률 ⬇️
    - Why? 해시 테이블은 **등호(=) 연산**에 최적화된 기능!
    - DB에선 부등호(<, >) 연산이 자주 사용되며, 해시 테이블 내의 데이터들은 정렬X
        
        = 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾기 불가능…
        

## 2. **B- Tree**

> 트리 자료구조의 일종 → 이진트리를 확장해 하나의 노드에 2개 이상의 노드를 가질 수 있는 구조
> 

트리 구조에서 노드의 종류

- 가장 상단에 있는 노드 = root 노드
- 중간에 있는 노드 = branch 노드
- 가장 하단에 있는 노드 = leaf 노드

즉, key 값을 이용해 찾고자 하는 데이터를 **트리 구조를 이용**해 찾는 방법!

## 3. **B+ Tree**

> B- tree의 확장개념 구조
> 

- 브랜치 노드에 key만 담아두고, data는 담지 않음
- 오직 리프 노드에만 key와 data를 저장
- leaf 노드끼리 Linked list로 연결되어 있음

**B+ tree의 장점**

- 리프 노드를 제외하고 데이터를 담아두지 않음
    
    → 메모리를 더 확보함으로써 더 많은 key들을 수용 가능
    
- 하나의 노드에 더 많은 key들을 보관 = 트리의 높이는 더 낮아짐 = 검색 속도 ⬆️
- 풀 스캔 시, B+ tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 됨
    
    = B- tree에 비해 빠름 (B- tree의 경우에는 모든 노드를 확인해야 함)
    

**B+ tree의 단점**

- 특정 key에 접근하기 위해서는 반드시 leaf node까지 가야 함
    
    (B-Tree의 경우 최상의 경우 특정 key를 root node에서 찾을 수 있음)
    

# 인덱스(**Index)**의 장점과 단점

## 인덱스(**Index)의 장점**

- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도 향상
- 인덱스를 사용하면 테이블 행의 고유성 강화 가능
- 테이블의 기본 키는 자동으로 인덱싱
- 필드 중에는 테이블 형식 때문에 인덱싱 할 수 없는 필드도 존재
- 여러 필드로 이루어진 다중 필드 인덱스를 사용하면 첫 필드 값이 같은 레코드도 구분 가능
    
    *cf. 액세스에서 다중 필드 인덱스는 최대 10개의 필드를 포함할 수 있다.*
    

## 인덱스(**Index)의 단점**

- 인덱스 제작 → .mdb 파일 크기 증가
- 사용자가 한 페이지를 동시에 수정할 수 있는 병행성 감소
- 인덱스된 필드에서 **데이터를 업데이트 하거나 레코드를 추가 또는 삭제할 때 성능 저하**
- 인덱스가 데이터베이스 공간을 차지해 추가적인 공간이 필요
    
    (= DB의 10% 내외의 공간이 추가로 필요)
    
- **데이터 변경 작업이 자주 일어나는 경우, 인덱스를 재작성해야 할 필요성 ⬆️ = 성능에 영향…**

# **상황 분석**

## 인덱스(Index)를 **사용하면 좋은 경우**

- Where 절에서 자주 사용되는 컬럼
- 외래키가 사용되는 컬럼
- Join에 자주 사용되는 컬럼

## 인덱스(**Index) 사용을 피해야 하는 경우**

- Data 중복도가 높은 컬럼
- DML이 자주 일어나는 컬럼

# **DML이 일어났을 때의 상황**

## **INSERT**

- 기존 Block에 여유가 없을 때, 새로운 Data가 입력됨
- 새로운 Block을 할당받은 후, Key를 옮기는 작업을 수행
- Index split 작업 동안 해당 Block의 Key값에 대해 DML이 블로킹 (= 대기 이벤트 발생)

> **Index split :** 인덱스의 Block들이 하나에서 두개로 나눠지는 현상
> 

## **DELETE**

- Table에서 Data가 delete 되는 경우 : **Data가 지워지고 다른 Data가 그 공간을 사용** 가능
- Index에서 Data가 delete 되는 경우 : **Data가 지워지지 않고 `사용 안 됨` 표시**만…
    
      = Table의 Data 수와 Index의 Data 수가 다를 수 있음
    
- Index를 사용해도 수행 소도를 기대하기 힘듦

## UPDATE

- Table에서 update가 발생 -> Index는 Update 사용 불가
    
      **= Index에는 Update 개념이 없음**
    
- Index에서는 **Delete가 발생한 후**, **새로운 Insert가 발생하여 작업**
    
      → 다른 DML보다 더 큰 부하 (2배의 작업이 소요)
    

---

*참고 자료*

[[CS 기초 - 데이터베이스] 인덱스](https://velog.io/@deannn/CS-%EA%B8%B0%EC%B4%88-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4)

[[CS] 인덱스(Index) 정의 및 장단점 ,hashmap , B+Tree](https://velog.io/@wonizizi99/CS-%EC%9D%B8%EB%8D%B1%EC%8A%A4Index-%EC%A0%95%EC%9D%98-%EB%B0%8F-%EC%9E%A5%EB%8B%A8%EC%A0%90)
# TCP/IP (흐름 제어/혼잡 제어)

[TCP/IP (흐름제어/혼잡제어) | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)

**<목차>**

---

# **TCP 통신이란?**

<aside>
💡

- 네트워크 계층 중 **전송 계층(4계층)에서 사용하는 프로토콜**
- 장치들 사이에 논리적인 접속을 성립(establish)하기 위해 연결을 설정하여 **신뢰성을 보장하는 연결형 서비스**
- Unreliable network에서, Reliable network를 보장할 수 있도록 하는 프로토콜
- Network Congestion Avoidance Algorithm을 사용
</aside>

**Unreliable (비신뢰성) vs Reliable (신뢰성)**

- Unreliable : 전송한 데이터그램이 유실될 수 있고, 순서가 바뀌어 도착할 가능성 ⬆️
- Reliable : 세그먼트가 유실될 경우 재전송을 통해 복구 + 순서가 바뀌어도 번호를 통해 맞춘 후 전달

**Reliable Network의 4가지 문제점 (조건)**

1. 손실 : packet이 손실될 수 있는 문제
2. 순서 바뀜 : packet의 순서가 바뀌는 문제
3. Congestion : 네트워크가 혼잡한 문제
4. Overload : receiver가 overload 되는 문제

**전송의 전체 과정**

1. **Application Layer (응용 계층)**
   - 데이터 생성 후, `socket`을 통해 데이터를 네트워크로 보낼 준비 완료
2. **Transport Layer (전송 계층)**
   - 데이터를 `segment` 단위로 감싼 후, `Network Layer`(네트워크 계층)에 전달
3. **전송 과정 (송신자 → 수신자)**
   - 송신자(Sender)는 데이터를 임시로 `send buffer`(보내는 버퍼)에 저장
   - 수신자(Receiver)는 도착한 데이터를 `receive buffer`(받는 버퍼)에 저장
4. **Application이 버퍼에서 읽기 시작**
   - 수신자의 응용 프로그램이 준비되면, `receive buffer`에 쌓인 데이터를 읽음
5. **Flow Control (흐름 제어)**
   - 송신자가 전송 속도 조절 (수신자의 버퍼가 가득 차지 않도록…)
6. **RWND (Receive Window)**
   - 수신자가 송신자에게 “내 버퍼에 남은 공간”을 알림
   - 송신자는 이 `RWND` 값을 보고 그만큼만 데이터를 전송

# 흐름 제어 **(Flow Control)**

## 흐름 제어의 개념

<aside>
💡

송신 측과 수신 측의 **데이터 처리 속도의 차이를 해결**하기 위한 방법

</aside>

- 수신 측의 데이터 처리 속도가 빠른 것 = 문제 X, 송신 측의 속도가 더 빠른 것 = 문제 발생
- 속도 차이로 인해 수신 측에서 제한된 저장 용량을 초과하면, 이후에 도착하는 데이터는 손실 가능성 ⬆️
  - 손실될 경우? 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번이 발생…
- 송신 측의 데이터 전송량을 수신측에 따라 조절할 필요

## 흐름 제어의 종류

### **1. Stop and Wait (정지-대기 방식)**

> 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법

![image.png](assets/image.png)

Stop and Wait 작동 순서

1. 송신 측은 데이터를 전송할 때마다 수신 측으로부터 확인 메시지인 ACK를 대기
2. 수신 측은 데이터를 수신할 때마다 해당 데이터를 확인하고 ACK를 송신 측에 전송
3. 만약 수신 측의 버퍼가 가득 차거나 수신 측이 데이터를 처리할 준비가 되지 않은 상태라면, ACK를 전송하지 않음
4. 3의 경우 ACK를 받을 때까지 대기하며, 데이터 전송을 중지
5. 수신 측이 버퍼를 비우거나 데이터 처리 준비가 되면 ACK를 송신 측에 전송하고, 송신 측은 데이터 전송을 다시 시작

### **2. Sliding Window (Go Back N ARQ)**

> 수신 측에서 설정한 ‘윈도우 크기’만큼 송신 측에서 확인 응답없이 세그먼트를 전송할 수 있게 하여, 데이터 흐름을 동적으로 조절하는 제어 기법

- TCP 통신에서 **한 번에 여러 개의 데이터를 연속적으로 보낼 수 있도록** 하는 제어 방식
- 수신자가 “한 번에 수령 가능한 데이터의 양(= 윈도우 크기)”을 미리 알려주면, 송신자는 **해당 크기만큼** 데이터를 쭉 보냄
- 중간에 매번 ACK(확인 응답)를 기다릴 필요 X → 전송 효율 ⬆️

**목적** : 전송은 되었지만, acked를 받지 못한 byte의 숫자를 파악하기 위해 사용하는 protocol

`LastByteSent` - `LastByteAcked` <= `ReceivecWindowAdvertised`

(현재 공중에 떠있는 패킷 수 <= sliding window)

(마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남아있는 공간) ==

(현재 공중에 떠있는 패킷 수 <= sliding window)

**동작 방식**

먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 해당하는 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

![image.png](assets/image%201.png)

Sliding Window 작동 순서

1. 송신 측은 수신 측에게 데이터를 전송할 때 윈도우 크기를 지정
2. 수신 측은 받을 준비가 된 데이터 범위를 윈도우 내에 표시

   (윈도우의 시작과 끝은 수신 측이 받을 수 있는 데이터 범위)

3. 송신 측은 윈도우 내의 데이터를 전송하고 ACK를 대기, ACK를 받으면 요청한만큼 윈도우를 이동
4. 수신 측은 데이터를 받은 경우 해당 데이터를 확인하고 ACK를 송신 측에 전송, 윈도우 크기를 조절한 후 어떤 데이터를 받았는지 알려줌
5. 송신 측은 ACK를 받으면 윈도우를 이동시켜 새로운 데이터를 전송하고, 데이터 전송 속도를 조절

**세부 순서**

![전송할 데이터](assets/image%202.png)

전송할 데이터

![image.png](assets/image%203.png)

![image.png](assets/image%204.png)

![image.png](assets/image%205.png)

# 혼잡 제어 **(Congestion Control)**

## 혼잡 제어의 개념

<aside>
💡

네트워크로 유입되는 데이터 트래픽의 양이 **네트워크 용량을 초과하지 않도록 유지**하는 방법

</aside>

- 데이터의 양이 라우터가 처리할 수 있는 양을 초과 → 초과된 데이터는 라우터가 처리 불가
- 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주한 후 계속 재전송…
  = 네트워크가 혼잡해짐
- 데이터 총량이 네트워크가 처리할 수 있는 허용량을 초과하면, 네트워크는 '혼잡 상태’가 됨
- 네트워크의 혼잡을 피하기 위해, 송신 측에서 보내는 데이터의 전송 속도를 강제로 줄이는 것
  (네트워크의 오버플로우 방지)

## 혼잡 제어의 종류

![image.png](assets/image%206.png)

### **1. AIMD (Additive Increase Multiplicative Decrease : 합 증가 곱 감소)**

> 네트워크 혼잡을 관리하기 위해 송신 측의 전송 속도를 동적으로 조절하는 알고리즘

![image.png](assets/image%207.png)

특징

- 처음에 패킷을 하나씩 보내고 문제가 없다면 윈도우 크기를 1씩 증가시키며 전송
  = **가산적 증가 (Additive Increase)**
- 패킷 전송에 실패하거나 일정 시간이 지난 경우 : 패킷 전송 속도를 절반으로 줄임
  = **곱셈적 감소 (Multiplicative Decrease)**

단점

- 초기에 높은 대역폭을 가진 네트워크를 사용하지 못해 시간이 오래 걸림
- 네트워크가 혼잡해지고 나서야 대역폭을 줄여야 함

### **2. Slow Start (느린 시작)**

> 초기에 전송되는 패킷의 수를 제한하고, 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우의 크기를 1로 줄이는 방식

![image.png](assets/image%208.png)

특징

- 패킷이 문제 없이 전송되면 각 ACK 패킷마다 윈도우 크기를 1씩 증가시킴
- 한 주기가 지나면 윈도우 크기는 2배가 됨
- 1, 2, 4, 8, 16, ... 처럼 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄임
- 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상 가능
- 느리게 출발하고 점점 증가 속도가 빨라지는 방식

### **3. Congestion Avoidance (혼잡 회피)**

> 느린 시작 이후 혼잡한 상황을 회피하기 위해 윈도우 크기를 선형적으로 증가시키는 방법

![image.png](assets/image%209.png)

특징

- 네트워크 혼잡 상태를 감지하고 윈도우 크기를 조절하여, 네트워크의 처치량을 넘지 않도록 함
- 혼잡 상태가 감지될 때까지 혼잡 윈도우 크기 1씩 증가
- 비교적 큰 값에서 시작하며, 일정하게 1씩 증가

### **4. Fast Retransmit (빠른 재전송)**

> 패킷 손실을 감지하고 재전송을 빠르게 수행하여 전체적인 성능을 유지하는 방법

![image.png](assets/image%2010.png)

특징

- TCP의 혼잡 조절에 추가된 정책
- 수신 측에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK를 전송
- 그러나 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK에 담아 전송…
  = 중간에 하나가 손실된다면 송신 측에서는 순번이 중복된 ACK를 받게 됨
  → 감지하는 순간 문제가 되는 순번의 패킷을 재전송하면 됨

### **5. Fast Recovery (빠른 회복)**

> 빠른 재전송으로 손실된 패킷을 재전송하고, 윈도우 크기를 조절하여 빠르게 정상 상태로 복구하는 방법

![image.png](assets/image%2011.png)

특징

- 혼잡 상태가 되면 윈도우 크기를 1이 아닌 반으로 줄이고, 선형 증가
- 해당 방법까지 적용하면 혼잡 상태를 겪고 나서부터는 순수 AIMD 방식으로 동작

---

_참고 자료_

[[네트워크] TCP/IP 흐름제어 & 혼잡제어](https://nayoungs.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPIP-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4-%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4)

[[Network] TCP/IP 흐름 제어, 혼잡 제어 — 미 개발 구역](https://jnsodevelop.tistory.com/78)

[[네트워크] TCP/IP 흐름 제어 & 혼잡 제어](https://steady-coding.tistory.com/507)

# Linked List

데이터가 추가될 때마다 메모리를 할당받고, 이 데이터들을 링크로 연결한 자료구조.

물리적 위치와 논리적 위치가 다를 수 있다.

## 특징

배열과 다르게 Node를 연결<br>
=resizing 불필요<br>
=배열을 복사해 요소를 이동시킬 필요 없음

값의 추가/삭제가 빈번이 일어나면 Array보다 알맞다.

#### 장점

- 공간의 제약이 없음
- 삽입/삭제 처리 속도가 빠름

#### 단점

- get 과정에서 Array보다 성능이 떨어짐 (무작위 접근이 가능한 Array에 비해 순차 접근만 가능해서)
- 참조자(prev, next)를 위해 추가적으로 메모리를 할당해야 함

## 시간복잡도

줄을 세운 게 아니라 이전/이후 노드의 위치만 조정하면 된다.

- 삽입: O(1)
- 삭제: O(1)
- index로 가져오기: O(n)
- 특정 위치에 삽입: O(n)

## 추가 자료

| 작업              | 시간복잡도(ArrayList) | 시간복잡도(LinkedList)    | 설명                |
| ----------------- | --------------------- | ------------------------- | ------------------- |
| add()             | O(1)                  | O(1)                      |                     |
| add(index, value) | O(n)                  | O(n)<br/>추가 자체는 O(1) | 찾는 데 시간이 걸림 |
| remove(index)     | O(n)                  | O(n)<br/>삭제 자체는 O(1) | "                   |
| remove(value)     | O(n)                  | O(n)<br/>삭제 자체는 O(1) | "                   |
| get(index)        | O(1)                  | O(n)                      |                     |
| indexOf(value)    | O(n)                  | O(n)                      |                     |

- 추가: 노드를 추가하므로 생성 시간 자체는 ArrayList보다 더 걸림
- 삭제: 탐색에 시간이 걸리지만 삭제 자체는 간단하므로 ArrayList보다 빠름

## 참고 자료

- [여러가지 자료구조](https://soliloquiess.github.io/study/2021/03/20/java_%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.html)

# 객체 지향 프로그램 OOP

처음엔 `순차적, 비구조적 프로그래밍`이 패러다임으로 나왔다.

> 필요한 게 있으면 계속 순서대로 추가해가며 구현하는 방식

이런 비구조적 프로그래밍에선 goto 문을 활용해 이전에 작성했던 코드가 필요하면 이동했다. 규모가 커지면 goto문을 무분별하게 사용하게 되어 실뜨기를 하는 것처럼 베베 꼬인다.

즉, 코딩보다 흐름을 이해하는 데 시간을 다 소비하게 된다. 이런 문제점을 해결하기 위해 탄생한 것이 `절차적, 구조적 프로그래밍`이다.

> 반복될 가능성이 있는 것들을 재사용 가능한 함수(프로시저)로 만들어 사용하는 구현 방식

여기서 절차는 함수(프로시저)를 뜻하고, 구조는 모듈을 뜻한다. 모듈이 함수보다 더 작은 의미긴 하지만 요즘은 큰 틀로도 같은 의미로 쓰임.

- 프로시저란?
  반환값(리턴)이 따로 존재하지 않는 함수. (ex. printf와 같이 출력하는 용도로 쓰이는 것 등-구체적으론 아니지만 유사함)
  저장 프로시저를 떠올리며 보면 더 쉬울 것.

하지만 이 패러다임도 너무 추상적이란 문제가 존재한다. (한 사물에 대한 자료형과 함수를 구조적 프로그래밍에선 따로 만들어야 하고, 이러다보니 구분이 힘들며 비효율적으로 코딩됨)

이런 특정한 개념의 함수와 자료형을 함께 묶어 관리하기 위해 탄생한 패러다임이 `객체 지향 프로그래밍`.

> 가장 중요한 점은 객체 내부에 자료형(필드)와 함수(메소드)가 같이 존재한다는 것. 이처럼 모든 물리적, 논리적 요소를 객체로 만드는 구현 방식.

이렇게 구현하면
1. 객체 간의 독립성이 생긴다
2. 중복 코드의 양이 줄어든다
3. 독립성이 확보되니 유지보수에 도움이 된다

## 특징
크게 네 가지 특성
### 1. 추상화 Abstraction
> 필요한 속성이나 행동을 추출하는 작업

세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것.
#### 왜 필요한가
하위 클래스가 추가될 때 같은 곳은 그대로 쓰고 추가로 필요한 것만 새로 만들기 위해

### 2. 캡슐화 Encapsulation
> 낮은 결합도를 유지할 수 있도록 설계하는 것

한 곳에 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것.
#### 결합도란
어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가 나타내는 것.<br>
의존도가 높아지면 객체 지향의 의미가 없다.<br>
객체 내부 모듈 간의 요소가 밀접하게 연관 있는 것으로 구성해 응집도를 높이고, 결합도를 줄여야 좋은 설계.

외부에서 접근할 필요가 없는 것들은 private으로 만들어 함부로 가져다 쓰는 걸 방지한다.

### 3. 상속 =일반화 Generalization
> 여러 개체들이 지닌 공통된 특성을 묶어 하나의 개념이나 법칙으로 성립하는 것

자식 클래스를 외부로부터 은닉하는 캡슐화의 일종. 이렇게 세부적인 사항을 감추어 외부에선 세부 클래스의 영향을 받지 않고 개발을 할 수 있다.

#### 단점
1. 상위 클래스(부모 클래스)의 변경이 어려워진다.
  > 자식 클래스가 영향을 받음
2. 불필요한 클래스가 증가할 수 있다.
  > 유사 기능 확장시 불필요한 클래스를 만들어야 할 수도 있음
3. 상속이 잘못 사용될 수 있다.
  > 같은 종류가 아닌 클래스를 재사용하기 위해 상속을 받으면 문제가 생길 수 있음

#### 해결책
객체 조립(Composition). 필드에서 다른 객체를 참조하는 방식.<br>
런타임 구조가 복잡해지고 구현이 어려운 단점이 존재하지만 변경 시 유연함 확보 가능.<br>
-> 같은 종류가 아닌 클래스를 상속하고 싶을 때 사용.

### 4. 다형성 Polymorphism
> 서로 다른 클래스의 객체가 같은 메시지를 받을 때 각자의 방식으로 동작하는 것

객체 지향의 핵심. 상속과 함께할 때 유용.<br>
부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 고쳐 쓰는 것.

#### 장점
1. 어떤 클래스가 참조되는지와 무관하게 프로그래밍 가능.
  > 새로운 자식 클래스가 추가되어도 부모 클래스의 함수를 참조하면 되기 때문에 다른 클래스에 영향 없음
2. 위와 일맥상통인데 코드가 간결해지고 유연성을 갖춤.

## 객체 지향 설계 과정
1. 제공할 기능을 찾고 세분화, 그 기능을 알맞은 객체에 할당
2. 객체에 기능을 구현하는 데 필요한 데이터 추가
3. 그 데이터를 이용하는 기능 추가
4. 기능은 최대한 캡슐화하여 구현
5. 객체 간에 어떻게 메소드 요청을 주고받을 지 결정

## 객체 지향 설계 원칙
SOLID
1. SRP(Single Responsibility) 단일 책임 원칙
    - 클래스는 단 한 개의 책임을 가진다.
    - 클래스를 변경하는 이유는 단 한 개여야 한다.
2. OCP(Open Closed) 개방 폐쇄 원칙
    - 확장엔 열리고 변경엔 닫혀 있어야 한다.
    - 기능 변경, 확장은 가능하지만 기능을 사용하는 코드는 수정X
3. LSP(Liskov Susstitution) 리스코프 치환 원칙
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상동작해야 한다.
    - 상속 관계가 아닌 클래스를 상속 관계로 설정 X
4. ISP(Interface Segregation) 인터페이스 분리 원칙
    - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
    - 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생해도 영향을 받지 않도록 구현
5. DIP(Dependency Inversion) 의존 역전 원칙
    - 고수준 모듈은 저수준 모듈의 구현에 의존해선 안 된다.
    - 저수준 모듈은 고수준 모듈에서 정의한 추상 타입에 의존
    - 저수준 모듈 변경해도 고수준은 변경 X
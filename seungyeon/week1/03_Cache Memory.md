# Cache Memory

속도가 빠른 장치와 느린 장치 사이에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리.

- ex) CPU 코어와 메모리 사이, 웹 브라우저의 캐시 파일-하드디스크와 웹페이지 사이
- 병목 현상: 특정 부분의 성능이 다른 부분에 비해 느려 전체 시스템의 성능이 제한되는 현상

CPU가 주기억장치에서 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장하고 다음에 이용할 땐 주기억장치가 아닌 캐시 메모리에서 먼저 가져와 속도를 향상.

CPU에 2~3개 정도 사용됨. (L1, L2, L3 캐시 메모리라 부름) 속도와 크기에 따라 분류한 것. 일반적으로 L1 캐시부터 사용됨. (CPU에서 가장 빠르게 접근)

장점

- 빠른 속도

단점

- 적은 용량
- 비싼 비용

#### 듀얼 코어 프로세서의 캐시 메모리

각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장됨.

이하 중요하진 않을 거 같지만 상세 설명.

> L1캐시가 128kb면 64/64로 나누어 64kb에 처리 직전의 명령어를 임시 저장하고, 나머지 64kg에 실행 후 명령어를 임시 저장. (명령어 세트로 구성, I-Cache - D-Cache)
>
> - L1: CPU 내부에 존재
> - L2: CPU와 RAM 사이에 존재
> - L3: 보통 메인보드에 존재

#### 디스크 캐시

주기억장치(RAM, ROM 등)와 보조기억장치(하드디스크) 사이에 존재하는 캐시.

## 캐시 메모리 작동 원리(참조 지역성의 원리)

- 시간 지역성

  for나 while 등 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음.

- 공간 지역성

  A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음.

캐시에 데이터를 저장할 땐 참조 지역성(공간)을 최대한 활용하기 위해 해당 데이터 뿐만 아니라, 옆 주소의 데이터도 같이 가져와 미래에 쓰일 것을 대비한다.

CPU가 요청한 데이터가 캐시에 있으면 Cache hit, 없어서 DRAM에서 가져오면 Cache Miss.

## 캐시 미스 경우 3가지

### 1. Cold miss=Compulsory miss

해당 메모리 주소를 처음 불러서 나는 미스.

### 2. Conflict miss

캐시 메모리의 서로 다른 block이 같은 캐시 메모리 주소에 할당되고자 해서 발생하는 미스.

direct mapped cache에서 많이 발생, 각 block이 모든 공간에 들어갈 자격을 갖는 fully associative cache에선 발생X.

### 3. Capacity miss

캐시 메모리의 공간이 부족해서 나는 미스.

크기를 키워서 문제를 해결하면 캐시 접근속도가 느려지고 파워를 많이 먹는단 단점이 생김.

## 구조 및 작동 방식

### Direct Mapped Cache

기본적인 구조. DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식.

ex) 00000, 01000, 10000, 11000의 메모리 주소가 000 캐시 메모리 주소에 맵핑

이때 000이 **인덱스 필드**, 인덱스를 제외한 앞의 나머지(00, 01, 10, 11)를 **태그 필드**라고 한다. 이처럼 캐시 메모리는 `인덱스 필드+태그 필드+데이터 필드`로 구성된다.

간단하고 빠르지만 메모리가 같은 캐시 공간을 사용하려고 할 때 Conflict Miss가 발생한다.

### Fully Associative Cache

비어있는 캐시 메모리가 있으면 마음대로 주소를 저장하는 방식. 저장은 간단하지만 찾을 때 어렵다.

조건이나 규칙이 없어서 특정 캐시 Set 안에 있는 모든 블럭을 한번에 찾아 원하는 데이터가 있는지 검색해야 한다. CAM이라는 특수한 메모리 구조를 사용해야하며, 가격이 비싸다.

### Set Associative Cache

Direct+Fully 방식. 특정 행을 지정하고, 그 행 안에 어떤 열이든 비어있을 때 저장한다.

Direct에 비해 검색 속도는 느리지만 저장이 빠르고, Fully에 비해 저장이 느리지만 검색이 빠른 중간형이다.

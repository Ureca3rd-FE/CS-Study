# 경쟁 상태(Race Condition)

**공유 자원** 에 여러 프로세스나 스레드가 **동시에 접근할 때** 접근 순서나 타이밍에 따라 **결과값이 달라질 수 있는 상황**을 말한다.

즉, **동시 접근 시 데이터의 일관성이 깨지고 예기치 못한 결과가 발생**한다.

> 두 스레드가 동시에 `count++` 연산을 수행할 때 하나의 결과가 덮어써져 최종적으로 값이 1만 증가하는 문제.

## Race Condition이 발생하는 경우

### 1. 커널 작업 중 인터럽트 발생

**문제 상황**

- 커널 모드에서 데이터를 로드해 수정하던 중 인터럽트가 발생하여 **같은 데이터를 다른 루틴이 조작**할 경우.
- 이로 인해 데이터 불일치 발생.

**해결 방법**

- 커널 모드에서 **작업 중에는 인터럽트를 비활성화** → CPU 제어권이 인터럽트 루틴으로 넘어가지 않도록 차단.

### 2. 프로세스가 System Call 수행 중 Context Switching 발생

**문제 상황**

- 프로세스1이 커널 모드에서 공유 데이터를 조작 중일 때 타이머 인터럽트로 인해 CPU 제어권이 **프로세스2로 넘어감**.
- 프로세스2가 동일 데이터를 수정하면 **프로세스1의 작업 결과 반영이 무효화**됨.

**해결 방법**

- 프로세스가 **커널 모드에서 작업 중일 때는 시간 초과로 CPU를 빼앗기지 않도록 설정**.
- 즉, 커널 모드에서의 Context Switching을 제한하여 일관성 유지.

### 3. 멀티 프로세서 환경에서 공유 메모리 접근

**문제 상황**

- 여러 CPU가 동시에 **커널 내부 공유 데이터**를 접근 및 수정.
- 하나의 CPU가 변경한 값이 다른 CPU에 반영되지 않거나 덮어씌워짐.

**해결 방법**

- 공유 데이터 접근 시 **Lock** 메커니즘 사용.
  - **Lock 획득(lock):** 한 프로세스/CPU만 자원 접근 허용
  - **Unlock:** 작업 완료 후 다른 프로세스가 접근 가능
- 대표적인 방법: **Spin Lock, Mutex, Semaphore 등**

# 데드락(Deadlock, 교착 상태)

두 개 이상의 **프로세스나 스레드가 서로 자원을 얻지 못해 다음 처리를 하지 못하는 상태**를 말한다.  
즉, **서로가 서로의 자원을 기다리며 무한히 대기 상태에 빠지는 현상**이다.

> 마치 외나무다리의 양 끝에서 두 사람이 서로 비켜주기를 기다리며 멈춰선 것과 같다.

## 데드락 발생 예시

- **프로세스1, 2가 자원1, 2를 모두 얻어야 한다고 가정**
  - `t1` : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음
  - `t2` : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림

→ 서로가 원하는 자원이 상대방에게 이미 할당되어 있어 **두 프로세스 모두 무한히 대기(wait)**  
→ 이것이 바로 **Deadlock (교착 상태)**

## 데드락 발생 상황

- **멀티 프로그래밍 환경**에서 한정된 자원을 여러 프로세스가 동시에 사용하려 할 때 발생
- 한 프로세스가 자원을 요청했는데, 해당 자원이 이미 사용 중이면 **대기 상태로 진입**
- 이때 대기 중인 프로세스들이 다시 실행될 수 없으면 **교착 상태 발생**

## 데드락 발생 조건 (필요충분조건)

데드락은 아래 **4가지 조건이 모두 성립**해야 발생한다.  
(→ 하나라도 깨뜨리면 데드락 예방 가능)

| 조건                             | 설명                                                                                |
| -------------------------------- | ----------------------------------------------------------------------------------- |
| **상호 배제 (Mutual Exclusion)** | 자원은 한 번에 **한 프로세스만** 사용할 수 있다.                                    |
| **점유 대기 (Hold and Wait)**    | 최소한 하나의 자원을 점유한 상태에서 **다른 자원을 추가로 요청하며 대기**해야 한다. |
| **비선점 (No Preemption)**       | 다른 프로세스에 할당된 자원을 **강제로 빼앗을 수 없다.**                            |
| **순환 대기 (Circular Wait)**    | 프로세스들이 **원형 형태로 자원을 기다리는 상황**이 존재해야 한다.                  |

## 데드락 처리 방법

데드락을 처리하는 방법은 크게 **예방(Prevention)**과 **회피(Avoidance)** 그리고 **탐지(Detection)**와 **회복(Recovery)** 으로 나뉜다.

### 예방과 회피

#### 1. 예방

> 데드락 발생 조건 중 **하나를 제거**하는 방식 (자원 낭비가 큼)

| 제거할 조건        | 해결 방법                                                             |
| ------------------ | --------------------------------------------------------------------- |
| **상호 배제 부정** | 여러 프로세스가 공유 자원을 동시에 사용하도록 허용                    |
| **점유 대기 부정** | 프로세스가 시작되기 전 **모든 자원을 한 번에 할당**                   |
| **비선점 부정**    | 자원을 점유한 프로세스가 다른 자원을 요구할 경우 **기존 자원을 반납** |
| **순환 대기 부정** | 자원에 **고유 번호를 부여하고 순서대로 요청**하도록 함                |

> 단점: 시스템 자원의 활용률이 낮아지고 낭비가 많음.

#### 2. 회피

> 데드락이 **발생할 가능성이 있는 상황을 미리 피하는 방법**

##### 은행원 알고리즘 (Banker’s Algorithm)

- 은행에서 모든 고객의 요구를 만족시킬 수 있도록 현금을 배분하는 원리에서 유래
- **자원을 요청할 때**, 해당 요청을 수락하더라도 시스템이 **안정 상태** 를 유지할 수 있는지 검사
- **안정 상태**이면 자원 할당, 아니면 대기시킴

> 즉, “이 요청을 승인해도 교착 상태가 생기지 않을까?”를 미리 계산 후 결정함.

### 탐지와 회복

#### 1. 탐지

> 데드락 발생을 **허용**한 뒤, 주기적으로 탐지 알고리즘을 실행해 확인한다.

- **자원 할당 그래프**를 사용
- 데드락 탐지 시 알고리즘 실행으로 **오버헤드 발생**
- 탐지 결과, **사이클이 존재하면 데드락 발생**

#### 2. 회복

> 이미 발생한 데드락을 해결하는 단계

##### (1) 프로세스 종료

- 교착 상태에 있는 **모든 프로세스 종료**
- 혹은 **하나씩 종료**하며 교착 상태가 해소될 때까지 반복

##### (2) 자원 선점

- 교착 상태의 프로세스가 점유 중인 자원을 **강제로 회수하여 다른 프로세스에 할당**
- 일시적으로 해당 프로세스를 **중단** 시킴
- 우선순위가 낮거나 수행 횟수가 적은 프로세스 위주로 자원을 선점

## 주요 면접 질문 요약

- **Q1. 데드락(교착 상태)이란 무엇인가요?**  
  → 서로 자원을 점유한 채 상대방의 자원을 기다리며 무한 대기하는 상태.

- **Q2. 데드락 발생 조건 4가지는 무엇인가요?**  
  → 상호 배제, 점유 대기, 비선점, 순환 대기.

- **Q3. 은행원 알고리즘이란?**  
  → 자원 요청 시 시스템이 안전 상태인지 검사하여 교착 상태를 회피하는 알고리즘.

- **Q4. 식사하는 철학자 문제란? (기아상태/교착상태 예시)**  
  → 철학자들이 젓가락 두 개를 모두 집어야 식사할 수 있는 상황에서,  
  모든 철학자가 한쪽 젓가락만 잡은 채 기다리면 **교착 상태 발생.**

#### 해결 방법 예시

- **철학자를 n명 대신 n−1명만 앉힌다.**

  - **예방(Prevention)**
  - 효과: **순환 대기**가 성립하지 않도록 함. 항상 최소 한 쌍의 젓가락이 비어 어느 한 철학자가 두 개를 모두 집을 수 있어 교착이 생기지 않음.

- **두 젓가락 모두 사용할 수 있을 때만 집도록 한다.** (둘 다 가능할 때만 일괄 취득)

  - **예방(Prevention)**
  - 효과: **점유 대기**를 깨뜨림. 한 젓가락을 쥔 채 다른 젓가락을 기다리는 상황을 금지.

- **일부는 왼쪽→오른쪽, 나머지는 오른쪽→왼쪽 순서로 집게 한다.** (자원 순서 강제/번호 부여)
  - **예방(Prevention)**
  - 효과: 자원에 **전역 순서**를 부여하여 **순환 대기**를 제거.

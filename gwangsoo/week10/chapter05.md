# Blocking I/O & Non-Blocking I/O

I/O 작업은 커널에서만 수행할 수 있으므로  
유저 프로세스(또는 스레드)는 항상 커널에게 I/O를 요청하는 방식으로 동작한다.

## Blocking I/O

### 동작 방식

1. 프로세스가 커널에게 I/O 요청을 보냄 (예: read, recvfrom)
2. 커널이 실제 I/O 작업을 수행
3. I/O가 완료되면 결과를 프로세스에게 반환

### 특징

- I/O가 끝날 때까지 프로세스는 **대기 상태**
- CPU를 거의 사용하지 않는 I/O 작업 때문에 스레드가 멈춰 있는 형태가 되어 **리소스 낭비 발생**
- 여러 클라이언트를 처리해야 하는 서버라면 한 요청을 기다리는 동안 다른 요청을 처리할 수 없으므로 **클라이언트마다 스레드를 따로 생성**해야 함
- 스레드 수가 증가하면서 **컨텍스트 스위칭이 많아지고 비효율적**

## Non-Blocking I/O

### 동작 방식

1. 프로세스가 `recvfrom` 같은 I/O 요청을 보냄
2. 커널은 즉시 응답
   - 데이터가 아직 없으면 **EWOULDBLOCK** 반환
   - 프로세스는 다른 작업을 계속 진행 가능
3. 커널의 recv 버퍼에 데이터가 준비되면 버퍼에서 유저 공간으로 데이터를 단순 복사하여 반환 메모리 복사이므로 매우 빠르게 완료됨

### 특징

- I/O 중에도 프로세스가 **중단되지 않음**
- 데이터가 준비되지 않았다면 즉시 반환되므로 다른 작업과 병행 가능
- 커널 버퍼에 데이터가 있을 때는 빠르게 복사만 수행하여 I/O보다 훨씬 빠르게 처리 가능

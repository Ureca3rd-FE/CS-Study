# 세마포어(Semaphore) & 뮤텍스(Mutex)

공유된 자원에 여러 프로세스나 스레드가 동시에 접근하면 **데이터 불일치나 충돌**이 발생할 수 있다.  
이 문제를 방지하기 위해 **한 번에 하나의 프로세스만 자원에 접근하도록 제어하는 기술**이 바로 *세마포어*와 *뮤텍스*이다.

## 1. 임계 구역(Critical Section)

**임계 구역**은 여러 프로세스가 **공유 데이터를 접근하는 코드 영역**이다.  
동시에 접근하면 잘못된 결과가 발생할 수 있으므로 **한 시점에 오직 하나의 프로세스만 접근**해야 한다.

임계 구역 문제를 해결하기 위해 다음 세 가지 조건을 만족해야 한다.

- **상호 배제**: 한 번에 하나의 프로세스만 진입 가능
- **진행**: 임계 구역에 들어갈 수 있는 프로세스가 있으면 진입 가능해야 함
- **유한 대기**: 무한정 대기하지 않아야 함

## 2. 세마포어(Semaphore)

세마포어는 **공유 자원 접근을 제어하기 위한 정수형 변수**로 자원의 개수를 의미한다.  
운영체제에서 **프로세스 간 동기화**나 **임계 구역 접근 제어**를 위해 사용된다.

### (1) P, V 연산

| 연산     | 의미                                                                             |
| -------- | -------------------------------------------------------------------------------- |
| **P(S)** | 자원 요청(임계 구역 진입 전 수행). `S == 0`이면 대기, `S > 0`이면 1 감소 후 진입 |
| **V(S)** | 자원 반납(임계 구역 종료 후 수행). `S`를 1 증가시키고 대기 중인 프로세스를 깨움  |

### (2) 동작 예시

- 초기값 `S = 1`
- 프로세스 A가 `P(S)` 실행 → `S = 0`, 임계 구역 진입
- 프로세스 B가 `P(S)` 실행 → `S = 0`이므로 대기
- A가 `V(S)` 실행 → `S = 1`, B가 대기에서 깨어나 진입 가능

### (3) 의사 코드

```plaintext
procedure P(S)
while S == 0 do wait
S := S - 1
end P

// --- 임계 구역 ---

procedure V(S)
S := S + 1
end V
```

## 3. 뮤텍스(Mutual Exclusion, Mutex)

**뮤텍스**는 한 번에 하나의 스레드만 자원을 사용할 수 있도록 하는 *이진 세마포어*이다.

- 상태값: **0(잠금)** / **1(해제)**
- **lock()**: 임계 구역 진입 시도 (이미 잠겨 있으면 대기)
- **unlock()**: 임계 구역 해제 (다른 스레드 접근 가능)

### (1) 세마포어와의 차이점

| 구분        | 세마포어                 | 뮤텍스         |
| ----------- | ------------------------ | -------------- |
| 제어 단위   | 프로세스 / 스레드        | 스레드         |
| 자원 개수   | 여러 개 가능             | 1개만          |
| 동기화 방식 | P / V 연산               | lock / unlock  |
| 상태 값     | 0 이상 정수              | 0 또는 1       |
| 사용 대상   | 프로세스 간 or 스레드 간 | 주로 스레드 간 |
| 예시        | 생산자-소비자 문제       | 임계 구역 보호 |

## 4. 주요 상호 배제 알고리즘

### (1) 데커(Dekker) 알고리즘

`flag`와 `turn` 변수를 이용하여 두 프로세스의 진입 순서를 조정한다.

```plaintext
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
        if(turn == j) { // j가 임계 구역 사용 중이면
            flag[i] = false; // 프로세스 i 진입 취소
            while(turn == j); // turn이 j에서 변경될 때까지 대기
            flag[i] = true; // j turn이 끝나면 다시 진입 시도
        }
    }
}

// ------- 임계 구역 ---------

turn = j; // 임계 구역 사용 끝나면 turn을 넘김
flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

### (2) 피터슨(Peterson) 알고리즘

서로에게 진입 기회를 양보하는 방식이다.

```plaintext
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    turn = j; // 다른 프로세스에게 진입 기회 양보
    while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
    }
}

// ------- 임계 구역 ---------

flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

### (3) 제과점(Bakery) 알고리즘

여러 프로세스가 있을 때 **번호표를 받아 순서대로 임계 구역에 진입**한다.

```plaintext
while(true) {
    isReady[i] = true; // 번호표 받을 준비
    number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정
    isReady[i] = false; // 번호표 수령 완료

    for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
        while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
        while(number[j] && number[j] < number[i] && j < i);

        // 프로세스 j가 번호표 가지고 있어야 함
        // 프로세스 j의 번호표 < 프로세스 i의 번호표
    }
}

// ------- 임계 구역 ---------

number[i] = 0; // 임계 구역 사용 종료
```

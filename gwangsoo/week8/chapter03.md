# DB 트랜잭션(Transaction)

트랜잭션은 **데이터베이스의 상태를 변경하기 위해 수행되는 작업의 논리적 단위**이다.  
여러 SQL 명령(SELECT, INSERT, UPDATE, DELETE 등)을 하나의 묶음으로 실행하는 개념이다.

## 특징

- **원자성(Atomicity)**  
  트랜잭션의 작업은 전부 수행되거나 전혀 수행되지 않아야 한다.

- **일관성(Consistency)**  
  트랜잭션 수행 전후로 데이터는 항상 일관된 상태를 유지해야 한다.

- **독립성(Isolation)**  
  동시에 실행되는 트랜잭션끼리는 서로의 작업에 간섭할 수 없다.

- **지속성(Durability)**  
  커밋된 트랜잭션의 결과는 시스템 장애가 발생해도 영구적으로 보존된다.

## Commit & Rollback

- **Commit**  
  트랜잭션이 정상적으로 끝났음을 알리는 명령으로 변경 내용이 DB에 영구 반영된다.

- **Rollback**  
  트랜잭션 중 오류가 발생했을 때 트랜잭션 시작 상태로 되돌리는 명령이다.

## Transaction 관리를 위한 DBMS 전략

DBMS는 장애 복구를 위해 UNDO/REDO를 지원하며 이를 결정하는 핵심은 **버퍼 관리 정책**이다.

### 1. DBMS 구조

- 저장 공간은 디스크에 위치하고 페이지 단위로 읽고 쓴다.
- 일부 페이지는 메인 메모리에 캐시된다.
- 트랜잭션 작업은 대부분 메모리의 페이지에서 처리된다.

### 2. Buffer(Page) Manager

- 디스크 페이지를 메모리로 가져오고 교체하는 모듈.
- 어떤 페이지를 메모리에 유지할지 언제 디스크에 내릴지 결정한다.

### 3. UNDO

트랜잭션이 실패했을 때 **원래 상태로 되돌리는 작업**이다.  
이는 버퍼 정책 중 *steal 여부*에 따라 필요성이 결정된다.

#### steal 정책

- 수정된 페이지를 **트랜잭션 종료 전에도 디스크에 쓸 수 있음**
- 메모리를 효율적으로 사용 가능
- 실패 시 **UNDO 필요**
- 대부분의 DBMS가 채택

#### ¬steal 정책

- 수정된 페이지를 **트랜잭션 종료(Commit/Rollback)까지 메모리에 유지**
- UNDO가 필요 없음
- 대규모 메모리가 필요

### 4. REDO

커밋된 트랜잭션의 변경을 **디스크에 다시 반영**하는 작업이다.  
이는 *force 여부*에 따라 필요성이 달라진다.

#### FORCE 정책

- Commit 시점에 수정된 페이지를 즉시 디스크에 반영
- Commit = 항상 디스크에 반영
- REDO 불필요

#### ¬FORCE 정책

- Commit 시점에 디스크 반영을 미룸
- 이후 시스템 장애가 발생하면 다시 반영해야 함
- **REDO 필요**
- 대부분의 DBMS가 채택

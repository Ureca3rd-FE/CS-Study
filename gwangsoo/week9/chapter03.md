# TCP/IP (흐름제어 / 혼잡제어)

- 네트워크 통신에서 사용하는 신뢰적인 연결 방식
- TCP는 unreliable network 위에서 reliable network를 보장하기 위한 프로토콜
- 내부적으로 여러 **network congestion avoidance algorithm**을 사용

## TCP가 reliable network를 보장하기 위해 해결해야 하는 4가지 문제

1. **손실** : 전송 중 패킷이 사라질 수 있음
2. **순서 바뀜** : 패킷이 도착 순서대로 오지 않을 수 있음
3. **혼잡** : 네트워크가 과부하되어 지연·손실 발생
4. **Overload** : receiver가 처리 가능한 양보다 많은 데이터 수신

## 흐름제어 / 혼잡제어란?

### 흐름제어(Flow Control)

- 송신측과 **수신측의 데이터 처리 속도 차이**를 해결하는 기법
- 수신측이 감당할 수 있는 만큼만 패킷을 받도록 제어
- 핵심 방식: **receiver가 자신의 상태를 sender에게 광고**

### 혼잡제어(Congestion Control)

- 송신측의 전송 속도 vs 네트워크 전체가 처리 가능한 속도 차이를 해결하는 기법
- 혼잡이 감지되면 송신 속도를 줄이고 안정적이면 점진적으로 증가

## 전송의 전체 과정

1. **Application Layer**  
   sender 애플리케이션이 socket에 데이터를 쓴다.
2. **Transport Layer**  
   데이터를 segment로 감싸고 network layer로 전달한다.
3. sender는 데이터를 **send buffer**에 저장하고 receiver는 **receive buffer**에 저장한다.
4. receiver 애플리케이션이 준비되면 receive buffer에서 데이터를 읽는다.
5. 흐름제어의 핵심은 **receiver buffer가 넘치지 않도록 관리하는 것**.
6. 이를 위해 receiver는 자신의 남은 공간인 **RWND(Receive Window)** 를 sender에게 알려준다.

## 1. 흐름제어 (Flow Control)

수신측의 처리 속도보다 송신측이 빠르게 데이터를 전송하면 수신 버퍼가 넘쳐 데이터가 손실될 수 있다.  
이러한 손실은 불필요한 재전송, 응답 증가로 이어지기 때문에 송신측은 **수신측의 상태** 를 기준으로 전송량을 조절해야 한다.

### Stop and Wait

- 패킷 1개 전송 → ACK 수신 후 다음 패킷 전송
- 구조는 단순하지만 성능은 매우 낮다.

## Sliding Window (Go-Back-N ARQ)

수신측이 설정한 **윈도우 크기만큼** 송신측이 **ACK 없이 여러 세그먼트를 연속 전송**할 수 있게 하는 방식이다.  
송신측은 현재 *전송되었지만 아직 ACK를 받지 못한 데이터량*을 관리하면서 흐름을 조절한다.

### 목적

- 전송되었지만 미확인(미수신 ACK) 상태의 바이트 범위를 추적하고
- 수신측이 허용한 범위(RWND) 내에서만 전송하기 위함

### 동작 방식

1. 윈도우 범위 안에 있는 패킷을 모두 전송
2. ACK가 도착하면 윈도우가 앞으로 “슬라이드”
3. 새롭게 열린 범위만큼 추가 전송 가능

## Window 개념

TCP/IP를 사용하는 모든 호스트는

- **송신 윈도우(Send Window)**
- **수신 윈도우(Receive Window)**  
  두 종류를 갖는다.

3-Way Handshake 과정에서 송신측은 **수신측이 광고한 Receive Window 크기**(RWND)에 자신의 Send Window 크기를 맞춘다.

## 2. 혼잡제어 (Congestion Control)

송신된 데이터는 LAN, WAN 등을 지나 여러 라우터를 통과하며 전달된다.  
이때 특정 라우터에 데이터가 몰리면 라우터는 모든 패킷을 처리하지 못하고 버퍼가 가득 차며 **패킷 손실, 지연, 재전송**이 발생한다.  
이러한 악순환이 바로 **혼잡(Congestion)** 이며 이를 방지, 완화하는 기능이 **혼잡제어**이다.

흐름제어가 **송신측 ↔ 수신측 간 속도 차이**를 해결하는 것이라면,  
혼잡제어는 **네트워크 전체(라우터 포함)의 흐름**을 조절하는 더 넓은 개념이다.

## 혼잡제어 기법

### AIMD (Additive Increase / Multiplicative Decrease)

- 초기: 패킷을 하나씩 보내기 시작
- 성공적으로 ACK가 오면 **윈도우 크기를 1씩 증가(선형 증가)**
- 혼잡(패킷 손실 또는 타임아웃) 발생 시 **윈도우 크기를 절반으로 감소(곱셈 감소)**
- 공평한 알고리즘이며 시간이 지나면 여러 송신자가 비슷한 속도로 수렴
- 단점
  - 초기에 네트워크 대역폭을 충분히 활용하기 어렵다
  - 혼잡 발생 이후에야 속도를 줄인다(사후 대응)

### Slow Start (느린 시작)

AIMD는 안정 구간에서는 효율적이지만 초기에 속도 증가가 너무 느리다.  
이를 해결하기 위해 설계된 방식이 Slow Start이다.

- 초기: 1 패킷 전송 시작
- ACK가 올 때마다 **윈도우 크기를 1씩 증가 → 한 라운드마다 2배 증가(지수 증가)**
- 큰 대역폭을 빠르게 활용 가능
- 혼잡이 감지되면 **윈도우를 1로 초기화**
- 이후
  - **혼잡이 발생했던 윈도우 크기의 절반까지는 지수 증가**
  - 그 이후는 1씩 증가(AIMD처럼 동작)

### Fast Retransmit (빠른 재전송)

패킷 손실을 타임아웃으로 기다리지 않고 더 빠르게 감지하는 기법이다.

- 패킷 하나가 손실되면 receiver는 “정상적으로 받은 마지막 패킷 번호”에 대한 ACK를 반복해서 보낸다(중복 ACK).
- 송신측은 **중복 ACK가 3개** 도착하면 해당 패킷이 손실되었다고 판단하여 즉시 재전송한다.
- 약한 혼잡 신호로 판단하고 윈도우 크기를 줄인다.

### Fast Recovery (빠른 회복)

Fast Retransmit 이후 윈도우를 1로 떨어뜨리는 대신

- **윈도우를 절반으로 감소**
- 이후 **선형 증가(AIMD 방식)** 로 회복

이 방식은 네트워크가 완전히 혼잡한 것이 아니라 “약한 혼잡”인 경우를 대비한 것으로 불필요한 속도 저하를 줄인다.

## TCP Tahoe

- **혼잡 감지 = 타임아웃 또는 중복 ACK 3회**
- 혼잡 발생 시 **cwnd를 1로 초기화**
- 그 후 **Slow Start**로 다시 지수 증가 시작
- 매우 보수적인 방식 → 안정성은 높지만 속도 회복이 느림

## TCP Reno

- **Fast Retransmit + Fast Recovery** 도입
- 중복 ACK 3회 → cwnd를 **절반으로 감소** (1로 떨어뜨리지 않음)
- Timeout → **cwnd를 1로 초기화** 및 **Slow Start** 진행
- 이후 **선형 증가(AIMD)** 로 회복
- Tahoe보다 혼잡 이후 회복이 훨씬 빠름

## 참고

- [[Network] TCP 혼잡제어, Congestion Control](https://velog.io/@nnnyeong/Network-TCP-%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4-Congestion-Control)

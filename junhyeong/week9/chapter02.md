# 9주차 🛜네트워크

## Chap02. TCP 3 & 4 way handshake

### #0. TCP (Transmission Control Protocol)란?

#### 개념

- 네트워크에서 데이터를 신뢰성 있게, 순서대로, 정확하게 전달하기 위해 만들어진 연결지향형 전송 프로토콜
- 전송 계층(4계층)의 프로토콜
- 통신을 시작하기 전에 연결을 설정함 (3-way handshake)
- 통신이 끝나면 연결을 종료함 (4-way handshake)
- 데이터 전송 중 손실, 중복, 순서가 바뀌어도 복구 가능

#### 특징

1. 연결 지향: 3-way handshake로 연결 설정, 4-way handshake로 종료
2. 신뢰성 보장: ACK 재전송, 번호(SEQ), 체크섬 등으로 오류 복구
3. 순서 보장: 순서가 꼬인 세그먼트 재조립
4. 흐름 제어: 수신 능역에 맞춰 전송 속도 조절
5. 혼잡 제어: 네트워크 혼잡 시 정송량 감축
6. 세그먼트 단위 전송

#### 용어

- **통신 방향의 동작 방식**
  - 전이중 (Full Duplex)
    - 개념: 양쪽이 동시에 송신/수신이 가능한 통신 방식
    - 특징
      - 두 방향으로 동시 전송 가능
      - 충돌 없음
      - 대역폭이 넓음
  - 반이중 (Half Duplex)
    - 개념
      - 한쪽이 전송하는 동안에는 다른쪽은 수신만 가능하고,
      - 수신하는 동안에는 전송할 수 없는 방식
    - 특징
      - 동시에 송수신 불가
      - 한 방향씩 번갈아 통신
      - 충돌 가능 -> 충돌 감지 알고리즘 필요 (예-CSMA/CD)

```
// TCP 패킷 = TCP 헤더 + 데이터
TCP 헤더 = [
  ["출발지 포트 번호 (16bit)", "도착지 포트 번호 (16bit)"],
  ["SEQ 번호 (32bit)"],
  ["ACK 번호 (32bit)"],
  ["dataoffset (4bit)", "reserved (3bit)", "TCP 제어 플래그 (9bit)", "Window size (16bit)"],
  [Checksum(16bit), Urgent Pointer (16bit)]
]
```

- **출발지 포트 번호 (Source Port)** : 송신 측 애플리케이션을 식별하는 번호
- **도착지 포트 번호** : 수신 측 애플리케이션을 식별하는 번호

- **SEQ 번호**

  - 전제
    - TCP는 데이터 전체를 하나의 바이트 흐름으로 인식
    - TCP 세그먼트는 이 바이트 스트림의 일부를 잘라서 보내는 구조 (바이트들로 구성됨)
    - 이 때, TCP헤더는 데이터 흐름에 포함되지 않음
  - 해당 데이터가 시작되는 바이트 번호를 의미
  - 데이터가 순서대로 도착했는지 판단하기 위한 기준

- **ACK 번호**

  - **ACK 패킷**: ACK 플래그가 1로 설정된 **TCP 패킷**
  - ACK 패킷에서 유효한 필드
  - 수신자가 다음에 받고 싶은 바이트의 SEQ 번호를 말해주는 값

  - 예시
    - 세그먼트 1
      - SEQ 번호: 1000
      - 데이터길이: 4바이트 = 1000~1003
      - ACK 번호(다음 SEQ번호): 1004
    - 세그먼트 2
      - SEQ 번호: 1004
      - 데이터길이: 10바이트 = 1004~1013
      - ACK 번호: 1014
    - 세그먼트 3
      - SEQ 번호: 1014
      - 데이터길이: 8바이트 = 1014~1021
      - ACK 번호: 1022

- **Data Offset**

  - TCP 헤더의 전체 길이를 나타내는 필드
  - TCP 세그먼트 해석(파싱) 시 필요한 정보인 "헤더 끝 위치"와 "데이터 시작 위치"를 알려줌
  - 옵션 사용 여부 확인
  - 4바이트 단위 블록 개수로 헤더길이를 표현
    - 예: Data Offset: 5 -> 5 x 4(바이트) = 20(바이트)
  - 4바이트 단위인 이유
    - CPU효율는 4바이트 단위로 처리하는 것이 효율적
    - TCP 헤더 구조가 4바이트 경계에 맞춰서 설계됨
    - 이때 옵션이 추가됨에 따라 길이가 늘어나는데 4바이트 단위로 증가함

- **reserved**

  - 미래에 TCP 확장 기능 사용 시
  - 기존 구조를 깨지 않고 새플래그/기능을 추가할 수 있도록 남겨둔 자리

- **TCP 제어 플래그**: TCP 헤더 내에 있는 제어 플래그 비트
  - SYN (Synchronize)
    - 연결 요청 신호 (초기 SEQ 번호 동기화)
    - TCP 헤더 내의 SYN 제어 플래그가 1로 표기
  - ACK (Acknowledgement)
    - 상대가 보낸 세그먼트를 정상 수신했다는 것을 알려주는 신호
    - TCP 헤더 내의 ACK 제어 플래그가 1로 표기
    - 해당 플래그가 1일때, ACK 번호 필드가 유효해짐
  - FIN (Finish)
    - 연결 종료 요청 신호
    - TCP 헤더 내의 FIN 제어 플래그가 1로 표기
    - 해당 플래그가 1일때, 종료 프로세스 시작

---

### #1. TCP 3-Way Handshake (연결 설정)

#### 개념

- TCP가 서로 데이터 전송 전 정상적으로 상대와 통신 가능한지 확인하는 절차

#### 과정

```
[Client]                                          [Server]
    | ---------------- SYN (SEQ=x) ---------------->  |
    |                                                 |
    | <-------- SYN + ACK (SEQ=y, ACK=x+1) ---------  |
    |                                                 |
    | --------------- ACK (ACK=y+1) --------------->  |
    |                                                 |

-> 연결 ESTABLISHED
```

1. SYN (Client -> Server)
   - 클라이언트가 연결을 요청 (SYN)
   - 초기 SEQ 번호(x) 전송
2. SYN + ACK (Server -> Client)

   - 서버가 연결 요청 수락 (ACK) + 서버도 클라이언트에게 연결을 요청 (SYN)
   - 서버의 초기 SEQ 번호(y)와 ACK(x+1)을 전송
   - ACK 번호: x+1
     - 클라이언트가 서버의 ACK(x+1)을 받은 후,
     - 클라이언트가 전송하는 데이터의 SEQ 번호는 x+1부터 시작됨
   - 주의점
     - SYN 패킷과 ACK 패킷을 따로 보내는 것 X
     - SYN과 ACK 플래그가 동시에 설정된 패킷을 보내는 것 O

3. ACK (Client -> Server)
   - 클라이언트가 서버의 SYN + ACK 패킷을 정상 수신했음을 응답하는 신호 (ACK)
   - ACK 번호: y+1
     - 서버가 클라이언트의 ACK(y+1)을 받은 후,
     - 서버가 전송하는 데이터의 SEQ 번호는 y+1부터 시작됨
   - 연결 확립 (ESTABLISHED)

#### 연결 설정이 3번인 이유

- 서로 수신 가능 상태인지 확인
  1. 클라이언트쪽에서 **연결 시도**
  2. 서버쪽에서 **확인** 및 **연결 시도**
  3. 클라이언트쪽에서 **확인**
- 서로의 초기 SEQ 번호를 교환해야 함

---

### #2. TCP 4-Way Handshake (연결 종료)

#### 개념

- 데이터 전송이 끝난 후, 양쪽에서 각자 연결 종료 요청(FIN)을 보내는 과정
- TCP는 반이중(Half Duplex) 방식으로 종료 -> 양쪽이 따로 FIN 전송 (4단계 필요)
- TCP는 전이중(Full Duplex) 기반 프로토콜이지만, 연결 종료 과정은 반이중적으로 동작

#### 과정

```
[Client]                                         [Server]
    | -------------- FIN (SEQ=u) ------------------> |
    |                                                |
    | <------------- ACK (ACK=u+1) ----------------- |
    |                                                |
    |                         (서버가 아직 보낼 데이터가 남아 있다)
    |                                                |
    | <------------- FIN (SEQ=v) ------------------- |
    |                                                |
    | -------------- ACK (ACK=v+1) ----------------> |
    |                                                |

▶ 연결 종료 (Client는 TIME-WAIT 상태)

```

1. FIN (Client -> Server)
   - 클라이언트: 더 이상 보낼 데이터 없음 -> 종료 요청 (FIN)
   - SEQ 번호: u -> 이후 서버가 보낸 ACK 패킷의 ACK 번호가 u+1이라면 잘 받았다는 의미
2. ACK (Server -> Client)
   - 서버: 클라이언트의 FIN(u)을 정상 수신했음을 응답하는 신호 (ACK)
   - ACK 번호: u+1 -> FIN(u)을 잘 받았다는 응답
   - 이때, 서버가 보낼 데이터가 남아 있을 수 있음
   - 따라서 "서버 -> 클라이언트 방향"의 전송은 열려있는 상태 (서버측은 데이터 전송 가능)
3. FIN (Server -> Client)
   - 서버: 보낼 데이터가 더 이상 없음 -> 종료 요청 (FIN)
   - SEQ 번호: v -> 이후 클라이언트가 보낸 ACK 패킷의 ACK 번호가 v+1이라면 잘 받았다는 의미
4. ACK (Client -> Server)
   - 클라이언트: 서버의 FIN(v)을 정상 수신했음을 응답하는 신호 (ACK)
   - ACK 번호: v+1 -> FIN(v)을 잘 받았다는 응답
   - 클라이언트는 TIME-WAIT 상태로 잠시 대기 -> 지연 패킷 제거 + 마지막 ACK 유실 대비

#### TIME-WAIT이란?

- 개념: 클라이언트가 일정 시간 대기하는 TCP 종료 보호 상태
- 목적

  1. **지연 패킷 제거** (Remaining/Delayed Packet 제거)

  - TCP는 오래된 패킷(옛날 데이터)이 늦게 도착하는 경우가 있음 (중간 라우터-네트워크 구간에서 지연되면서 발생)
  - 만약 TIME-WAIT 하지 않을 경우
    - 클라이언트가 새로운 연결을 만들었을 때 오래된 패킷이 새 연결의 데이터로 섞일 수 있음
    - 클라이언트가 동일한 포트를 재사용하여 새 연결을 만드는 경우에 발생
  - 즉, TIME WAIT의 첫번째 목적은 오래된 패킷이 새로운 연결을 오염시키지 않도록 보호 시간을 제공하는 것

  2. **마지막 ACK 유실 대비** (Retransmission 대비)

  - 서버가 FIN(v)을 보냈는데, ACK(v+1)를 받지 못하면,
  - 타임아웃 후 FIN(v)을 재전송함
  - 만약 TIME-WAIT 하지 않을 경우
    - 클라이언트 입장에서, 서버가 다시 보낸 FIN(v)의 출처를 이전 연결인지, 새 연결인지 구분을 못함
    - 클라이언트가 동일한 포트를 재사용하여 새 연결을 만드는 경우에 발생
  - 즉, TIME WAIT의 두번째 목적은 재전송 FIN을 안전하게 처리할 수 있는 시간을 확보하는 것

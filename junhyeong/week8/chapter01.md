# 8주차 🛅데이터베이스

## Chap01. 인덱스 (Index)

### #1. 인덱스란?

#### 개념

- 데이터베이스에서 검색 속도를 높이기 위해 사용하는 자료구조
- 구성: (인덱스 키 + 데이터 위치) 쌍으로 저장
- 역할: 책의 목차처럼 필요한 데이터를 빠르게 찾을 수 있도록 안내해줌
- 예시
  |id (index key)|Row 주소 (Pointer)|
  |:--|:--|
  |101|0x01 (실제 데이터 블록 주소)|
  |102|0x05 (실제 데이터 블록 주소)|
  |103|0x09 (실제 데이터 블록 주소)|

#### 특징

- 일반적으로 B-Tree(균형 이진 트리) 구조
  - 정렬된 상태로 저장하여 O(logN)의 빠른 탐색 가능
  - (리프)노드는 실제 데이터의 물리적 주소를 가짐
  - MySQL, Oracle을 비롯한 대부분의 RDBMS에서 사용하는 구조 형식
  - 그 외 인덱스 구조: B+Tree, Hash Index, Full-Text Index, ...
- 장점
  - 조회 속도가 빨라짐 <- WHERE/ORDER BY/JOIN 조건에서 탐색 범위 줄임
  - 부하가 감소함 <- Full Table Scan 방지
  - 별도의 정렬 연산이 필요없음 <- 이미 정렬된 상태이므로
- 단점
  - 쓰기(INSERT/UPDATE/DELETE) 성능 저하 <- 인덱스 갱신 비용 발생
  - 인덱스 테이블을 저장하기 위한 디스크 공간 필요
  - 잘못된 인덱스 설계 시 비효율적임 (옵티마이저 혼란 유발) -> 자주 쓰이는 컬럼 중심으로 생성하기

#### SQL 예시

```sql
// 인덱스 생성
CREATE INDEX idx_users_column ON table_name(column_name);

// 인덱스 확인
SHOW INDEX From table_name;

// 인덱스 삭제
DROP INDEX idx_table_colun ON table_name;
```

#### 인덱스 동작 방식

1. 사용자 쿼리 조회 쿼리: `SELECT * FROM users WHERE email = "pjh1234@naver.com";`
2. DB 옵티마이저가 인덱스 존재 여부 확인
3. 인덱스 테이블에서 email값 탐색
4. 찾은 키의 RowID로 실제 데이터 블록 접근
5. 결과 반환 (Index Scan -> Full Table Scan 보다 빠르게 반환)

---

### #2. 인덱스 종류

- **클러스터형 인덱스(Clustered Index)**
  - 개념
    - 물리적 데이터 저장 순서 자체를 인덱스 순서로 정렬하는 방식
    - 테이블 자체가 인덱스 역할을 함 (인덱스와 테이블 분리 X)
    - 데이터가 인덱스 키를 기준으로 물리적으로 정렬되어 저장되는 것
    - 즉, B-Tree 인덱스의 리프 노드 자체가 데이터인 것
  - 특징
    - 테이블당 하나만 존재 (테이블이 곧 인덱스)
    - 데이터 정렬 순서가 인덱스 키 순서와 같음 (정렬은 한 기준만 가능)
    - 범위 검색 (Between, <, >)에서 효율적
    - 쓰기 비용 커짐 <- 데이터 정렬이 일어남
    - 인덱스 탐색 시 곧바로 데이터 접근 가능
- **보조 인덱스(Secondary Index)**
  - 개념
    - 인덱스와 실제 테이블이 분리되어 있는 구조
    - 인덱스 조회 후 다시 테이블로 이동하는 방식 (2단계 접근)
    - 인덱스는 정렬된 키 값과 데이터 위치(Row ID)만 보유
      - 키 값: 정렬 기준이 된 컬럼의 값들
      - 데이터 위치: 실제 테이블의 레코드가 저장되어 있는 주소
  - 특징
    - 여러개 생성 가능: 조회 조건에 따라 다양하게 설정
    - 인덱스 리프 노드에 데이터의 물리 주소를 저장
    - 검색 빠름 + 데이터 접근 시 추가 I/O 발생 (2단계 접근을 하므로)
    - 자주 검색되는 보조 컬럼에 적합: WHERE/JOIN/ORDER BY절에서 자주 쓰이는 컬럼

---

### #3. 인덱스 사용 상황

#### 좋은 상황

1. 검색(조회) 중심 테이블: SELECT가 잦고 WHERE/JOIN/ORDER BY절에 자주 쓰이는 컬럼

   - WHERE 조건에 자주 사용되는 컬럼: 탐색 범위 줄여줌
   - JOIN에 자주 사용되는 외래키: 조인속도를 향상 시켜줌

2. 카디널리티가 높은 컬럼

   - 중복도가 낮은 컬럼에서 효율적
   - 예: 주민번호, 학번, 이메일, 주문번호, ...

3. 자주 조회되는 + 변경 적은 컬럼: 읽기 중심 시스템, 로그성 데이터, 마스터 테이블, ...

#### 안좋은 상황

1. 데이터 변경이 잦은 테이블: INSERT/UPDATE/DELETE 시 인덱스도 함께 갱신해야함

   - **INSERT**
     - 테이블에 새로운 데이터 추가 시 인덱스에도 추가해야함
     - 기존 인덱스 블록에 여유가 없을 경우
       - 새로운 블록을 할당 받아 해당 컬럼(key)를 옮겨야하는 상황 발생 (Index Split)
       - 해당 과정에서 **DML Lock (대기 이벤트)** 발생
   - **UPDATE**
     - 인덱스에서는 UPDATE가 불가능
     - 기존 인덱스 DELETE 후 INSERT 수행 -> 작업이 재조정 비용 커짐
   - **DELETE**
     - 테이블에서는 해당 데이터가 지워지고 다른 데이터가 그 공간 사용 가능
     - 인덱스에서는 데이터가 지워지지 않고 사용 안됨 표시 (삭제 마크 처리)
     - 테이블의 데이터 수와 인덱스 데이터 수 달라지는 상황 발생

2. 중복도가 높은 컬럼

   - 값이 적어 효율이 낮음
   - 예: 성별, 학년, 지역코드, ...

3. 소량의 데이터를 가진 테이블

   - 인덱스 접근 시 2단계 접근 발생
   - 테이블 접근 시 1번 읽으면 됨
   - Full Table Scan이 더 나음

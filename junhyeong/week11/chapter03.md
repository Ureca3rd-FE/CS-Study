# 11주차 🔧소프트웨어 엔지니어링

# Chap03. 테스트 주도 개발 (TDD - Test Driven Development)

## #1. TDD란?

### 🔹개념

- 테스트 코드를 먼저 작성하고, 그 테스트를 통과하는 코드를 작성하는 방식의 개발 방법
- **테스트** -> **코드 작성** -> **리팩터링** 을 반복

### 🔹TDD의 3단계

#### 1. Red - 실패하는 테스트 작성

- 아직 구현한 코드가 없으므로 테스트는 반드시 실패함
- 개발자가 원하는 기능을 테스트로 정의하는 단계

#### 2. Greeen - 테스트를 통과시키는 최소한의 코드 작성

- 테스트를 통과시키기 위한 최소한의 기능만 구현하는 단계
- 구조나 최적화보단 **성공**에 집중

#### 3. Refactor - 코드 개선

- 테스트가 보장하므로 리팩터링을 보다 안정적으로 할 수 있음
- 코드의 품질을 올리는 단계 -> 중복 제거, 구조 개선, 성능 개선 등

---

## #2. TDD의 예시

### 1. Red - 실패하는 테스트 작성
- 아직 validatePassword 함수가 없으므로 실패가 뜸
- 실패하는 테스트를 작성하는 것
```js
// password.test.js
import { validatePassword } from "./password";

describe("비밀번호 검증", () => {
    test("8자 미만이면 false", () => {
        expect(validatePassword("abc12!")).toBe(false);
  });

  test("숫자가 없으면 false", () => {
      expect(validatePassword("abcdefgh!")).toBe(false);
  });

  test("특수문자가 없으면 false", () => {
      expect(validatePassword("abcd1234")).toBe(false);
  });

  test("조건 모두 만족 시 true", () => {
      expect(validatePassword("abcd1234!")).toBe(true);
  });
});
```
- 위 코드의 test() 함수는 Jest/Vitest의 테스트 함수
- 형식 `test("설명", ()=>{ 검증내용 })`
- "설명": 해당 테스트가 무엇을 검증하는지 나타내는 문자
- {검증내용}: 기대 동작을 코드로 표현
- 즉, 해당 테스트를 통과해야 한다는 요구사항을 코드로 표현한 것

### 2. Greeen - 테스트를 통과시키는 최소한의 코드 작성
- 테스트 4개를 통과시키기 위한 가장 단순한 코드만 작성함
- 구조, 품질 보다는 테스트 성공에 초점
```js
// password.js
export function validatePassword(pw) {
  if (pw.length < 8) return false;
  if (!/[0-9]/.test(pw)) return false;
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(pw)) return false;

  return true;
}
```

### 3. Refactor - 코드 개선
- 테스트가 있으므로 기능이 깨지지 않는다는 확신을 가지고 리팩터링 가능
- 중복제거 및 가독성 향상
```js
export function validatePassword(pw) {
  const rules = [pw.length >= 8, /[0-9]/.test(pw), /[!@#$%^&*(),.?":{}|<>]/.test(pw)];

  return rules.every(Boolean);
}
```
- 위 코드의 .test() 함수는 정규표현식의 내장 메서드
- `/정규식/.test("문자열")` -> true/false 반환
- 자바스크립트 내장 메서드로, 문자열이 특정 패턴에 맞는지 검사하는 기능

---

## #3. TDD를 사용하는 이유

### 🔹TDD의 특징

#### 1. 기능 명세를 먼저 정의함

- 테스트가 곧 요구사항 문서가 됨

#### 2. 버그가 줄어듬

- 테스트가 계속 돌면서 기존 기능이 깨지는 것을 잡아줌

#### 3. 리팩터링이 쉬움

- 테스트가 안전망이 되어 구조 개선을 더 편안하게 할 수 있음

#### 4. 코드가 간결하고 목적에 맞게 작성됨

- 불필요한 기능을 만들 확률이 감소함

#### 5. 테스트가 자동 문서 역할을 함

- 새로운 사람이 프로젝트를 보더라도, 테스트를 통해 동작을 이해할 수 있음

### 🔹TDD가 필요한 이유

#### 1. 요구사항이 명확해짐

- 테스트가 곧 요구사항 문서이며, 더 명확하게 작성하게 됨
  - 정확히 무엇을 만족해야 하는가?
  - 잘못된 입력이 들어오면 어떻게 되는가?
  - 예외 상황은 어떤 경우인가?
- 기능을 만들기 전에 명세가 확립됨 -> 요수사항 누락이 줄어듬

#### 2. 새로운 기능을 추가할 때, 기존 기능이 깨지는 것을 방지

- 보통의 프로젝트는 아래의 상황을 마주할 때가 있음
  - 수정 후 다른 기능이 망가지는 상황 발생
  - 어디서 에러가 나는지 바로 알기 힘듦
- TDD는 테스트가 안정망 역할을 함 -> 리팩터링/기능 추가 시 사이드 이펙트를 감지가 쉬움

#### 3. 디버깅 시간이 줄어듬

- 버그 발생 시 테스트가 정확히 알려줌 -> 어떤 테스트가 깨졌는지를 통해 문제를 명확하게 파악 가능
- 디버깅 시간이 줄어듬 -> 생산성이 증가함

#### 4. 설계 품질이 좋아짐 - 모듈화 및 단일 책임 원칙 지향

- 테스트를 작성하며 아래의 구조를 만들게 됨
  - 작은 함수
  - 하나의 책임만 갖는 모듈
  - 의존성이 적은 구조

#### 5. 협업 시 안정성 확보

- 테스트의 존재가 아래와 같은 안정성을 제공함
  - 특정 수정이 전체 시스템에 미치는 영향을 확인 가능
  - 코드 리뷰가 쉬워짐
  - 배포 안정성이 증가함

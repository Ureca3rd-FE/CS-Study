# 🖥️컴퓨터 구조

## CHAP01. 컴퓨터 시스템

- 컴퓨터 시스템은 크게 하드웨어와 소프트웨어로 이뤄져있다.

### #1. 하드웨어 : 하드웨어는 크게 필수장치와 주변장치로 나눠볼 수 있다.

#### 1. 큰 분류

- 필수장치

  - 중앙처리장치 (CPU) = 메인 프로세서(Main Processor) <br>
    - 명령어를 해석/실행하는 장치
  - 주 기억장치 = 메인 메모리 = 메모리 <br>
    - 작업에 필요한 프로그램/데이터/명령어를 저장하는 장소
      e.g. RAM, HDD, ...
    - RAM은 휘발성 메모리로 영구적으로 데이터를 저장하는 보조기억장치와 차이가 있다.
    - 종류
      - (1) DRAM : 저장된 데이터가 일정시간이 지나면 사라짐. 일정시간마다 재생 필요
      - (2) SRAM : 전력이 공급되는 동안 데이터 보관 가능. (재생 필요 X)
      - (3) SDRAM : 클록틱이 발생할 때 마다 데이터를 저장하는 동기식 DRAM
      - \+ 클록 : CPU속도와 관련된 단위.
        - 클록이 일정간격(클록사이클)마다 틱을 만듬
        - 틱에 맞춰 CPU내 구성요소들이 작성을 수행
        - 클록틱 = 틱 = 펄스 = Rising edge + Falling edge

- 주변장치
  - 입력장치 : 키보드, 마우스, 마이크, ...
  - 출력장치 : 모니터, 스피커, 프린터, ...
  - 저장장치 = 보조저장장치 = 보조기억장치 : 카세트테이프, CD, USB, SD카드, SSD, ...<br>
    - \+ 저장장치는 메모리보다 느리지만 용량이크며 데이터를 영구적으로 저장한다는 특징이 있다.
  - 메인보드 = 마더보드 : 다양한 부품들을 연결(버스)하는 커다란 판

#### 2. 시스템 아키텍처

- 폰노이만 아키텍처
  - CPU, 메모리, 저장장치, 입출력장치가 하나의 버스로 연결되어 있는 구조
  - 명령어와 데이터를 위한 메모리 인터페이스가 하나 -> 명령어를 읽을때, 데이터를 읽거나 쓸 수 없음
  - 모든 프로그램은 메모리에 올라와야 실행할 수 있음 -> 메모리가 유일한 작업공간
- 하버드 아키텍처
  - 명령어와 데이터를 위한 메모리 인터페이스가 분리되어있음 -> 버스 시스템이 상대적으로 복잡
- 폰 노이만 아키텍처가 중요한 이유
  - 명령어와 데이터가 동일한 메모리 공간에서 처리되므로 하드웨어 수정없이 소프트웨어만 변경하는 방식으로 여러 작업 수행이 가능 (범용성 up)
  - 해당 방식을 토대로 현대 컴퓨터 시스템은 폰 노이만 구조를 기본으로 설계됨
  - 병목현상이 발생하여 이를 해결하기 위한 기술들이 필요 <br>
    e.g. 메모리 계층구조, 캐시분할 등<br>
    \+ 병목현상 : 한 부분의 처리속도가 전체성능을 제한하는 현상. <br>
    폰 노이만 아키텍처의 경우에는 CPU와 메모리가 하나의 버스로 연결되어있는데, 메모리의 데이터 전송속도가 CPU의 처리 속도에 비해 상대적으로 느려 CPU가 데이터를 기다려야 하는 상황이 발생.

#### 3. 시스템 버스 : 하드웨어의 구성요소들을 물리적으로 연결하는 경로

- 주소 버스
  - 단방향 버스
  - 데이터와 명령어에는 메모리에 올라와 실행이 되는데 이때 위치(주소)가 전달될때 이동하는 통로
  - CPU에서 기억장치/입출력장치로의 방향으로 전달
  - MAR에서 들어와 주변장치로 나감
- 데이터 버스
  - 양방향 버스
  - 기억장치와 입출력장치의 명령어/데이터를 CPU로 보내거나
  - CPU의 연산결과를 기억장치와 입출력장치로 보냄
- 제어 버스
  - 양방향 버스
  - 하드웨어에 제어신호를 전달하는 통로
  - 종류 : 기억장치 읽기/쓰기, 버스 요청/승인, 인터럽트 요청/승인, 클록, 리셋 등
- 버스의 대역폭
  - 대역폭 : 한번에 전달할 수 있는 데이터의 최대크기 = CPU가 한번에 처리할 수 있는 데이터의 크기
  - 버스의 대역폭 = 레지스터의 크기 = 메모리에서 읽기/쓰기의 데이터 크기 = CPU의 bit

### #2. 소프트웨어

    - 시스템 소프트웨어 : 운영체제, 컴파일러, ...
    - 응용 소프트웨어 : 워드 프로세서, 엑셀, ...

<br>
<br>

## CHAP02. 중앙처리장치(CPU) 작동원리

### #1. CPU 구성요소

#### #1-1. 산술논리 연산장치 (ALU-Arithmetic Logic Unit)

- 데이터의 산술연산(사칙연산 등), 논리연산(AND, OR 등)을 수행
- 연산에 필요한 데이터를 레지스터에서 가져오고, 연산결과를 레지스터로 보냄

#### #1-2. 제어장치

- 명령어를 순서대로 실행되도록 제어하는 장치
- CPU에 작업지시
- 주기억장치에서 명령어를 해석하여 결과에 따른 제어신호를 연산장치, 기억장치, 입출력장치로 보내고, 이들에게 받은 신호를 통해 다음 수행동작 결정

#### #1-3. 레지스터

- 명령어/데이터/연산결과 등을 임시로 저장
- CPU마다 사용가능한 레지스터 수/크기 다름
- 종류
  - 범용 레지스터 : 연산에 필요한 데이터/연산결과를 임시로 저장
  - 특수목적 레지스터 : 특별한 용도로 사용<br>
    (1) MAR(메모리 주소 레지스터) - MMR(메모리관리자)이 접근해야할 메모리의 주소<br>
    (2) MBR(메모리 버퍼 레지스터) - MMR이 가져온 데이터를 임시로 저장<br>
    (3) PC(프로그램 카운터) - 다음에 실행한 명령어의 메모리 주소를 저장<br>
    (4) IR(명령어 레지스터) - 실행할 명령러를 저장<br>
    (5) AC(누산기) - 연산결과를 임시로 저장<br>

### #2. CPU의 동작과정

    1. 주기억장치는 입력장치의 입력데이터/보조기억장치의 프로그램을 읽어옴
    2. CPU는 주기억장치에 저장된 프로그램 명령어/데이터를 읽어와 처리하고 결과를 주기억장치에 저장
    3. 주기억장치는 처리결과를 출력장치/보조기억장치에 보냄
    4. 제어장치는 1~3과정을 순서대로 실행되도록 장치를 제어

### #3. 명령어 세트와 명령어 사이클

#### #3-1. 명령어 세트

- 명령어 세트 = 연산코드(Opeation Code) + 피연산자(Operand)
- 연산코드: 실행할 연산 - 연산/제어/데이터전달/입출력기능
- 피연산자: 필요한 데이터/저장위치 - 숫자/문자/논리데이터

#### #3-2. 명령어 사이클

- <b>CPU</b>가 <b>주기억장치</b>에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동
- 종류
  (1) 인출 사이클
  (2) 실행 사이클
  (3) 간접 사이클
  (4) 인터럽트 사이클

<br>
<br>

## CAHP03. 캐시 메모리

### #1. 캐시 (Cache)

    - 캐시 메모리라고 부르며, CPU와 메모리간의 속도차이(병목현상)를 완화하기 위해 메모리의 데이터를 임시로 저장하는 장소
    - 캐시히트 : 캐시에 원하는 데이터를 바로 찾음
    - 캐시미스 : 캐시에 없을때 메모리(DRAM)로 가서 데이터를 가져옴
        -종류
            (1) Cold miss : 해당 메모리 주소를 처음 불러서 나는 미스
            (2) Conflict miss : 캐시 메모리에 A, B를 저장해야하는데, A와 B가 같은 캐시 메모리 주소에 할당됨 (주소할당문제)
            (3) Capacity miss : 캐시 메모리 공간 부족 (공간문제)
    - 캐시 적중률 : 캐시히트 비율 (통상적으로 약 90%), 처리속도와 비례관계

    - 종류
        - 특수캐시(L1캐시) : CPU와 연결(CPU내부). 명령어/데이터를 구분하여 가져옴.
        - 일반캐시(L2캐시) : 메모리와 연결(CPU와 RAM사이). 모든 데이터를 가져옴.
        - L3캐시 : 메인보드에 위치.
        - \+ 캐시는 SRAM! (비쌈 -> 용량이 작음)
        - \+ 디스크 캐시: 주기억장치와 보조기억장치 사이에 존재하는 캐시

### #2. 캐시 메모리의 작동

    - 동작방식
        - 즉시 쓰기 (Write Through) : 캐시의 데이터가 메모리에 즉시 반영 <-> 성능 down

        - 지연 쓰기 (Write Back) = 카피백 : 변경내용을 모았다가 주기적으로 메모리에 반영 <-> 메모리와의 데이터 불일치 가능성 up

    - 작동원리
        - 시간지역성 : 한번 참조된 데이터는 다시 참조될 가능성이 높음. e.g. 반복문의 조건변수
        - 공간지역성 : 연속 접근된 상황에서, 참조된 데이터 근처에 있는 데이터가 다시 참조될 가능성 높음

    - 캐시 매핑 기법
        - 전제
            - 데이터 저장공간의 크기 1Byte, 캐시의 크기 4Byte, 메모리의 크기 16Byte (4개의 블록)
            - 각 블록은 같은 태그필드를 가짐
            - 블록내 각 데이터들은 서로다른 인덱스필드를 가짐
            - \+ 캐시메모리 = 인덱스필드 + 태그필드 + 데이터필드
        - 캐시 직접 매핑 (Direct Mapped Cache)
            메모리 내 각각의 태그필드에서 하나의 데이터들이 캐시 메모리에 할당
            캐시 내의 태그필드를 확인하여 접근하려는 데이터와 인덱스필드가 같으면 캐시히트
            conflict miss 발생 가능성
        - Fully Associative Cache
            저장할때 간단, 찾을때 모든 블럭 검색
            특수한 메모리 구조(CAM)을 사용 (비쌈)
        - 캐시 집합-연관 매핑 (Set Associative Cache)
            (1)+(2)의 방식
            Direct Mapped에 저장 빠름 (검색 느림)
            Fully Associate에 비해 검색 빠름 (저장 느림)

<br>
<br>

## CHAP04. 소수점 그리고 패리티비트 & 해밍코드

### #1. 소수점

#### #1-1. 고정 소수점 (Fixed Point)

    - 실수를 정수부 + 소수부로 표현 <br>
    e.g. 3.1415 = 정수부 3과 소수부 0.1415로 구성
    - 표현범위가 적어 표현에 제한 <br>
    32bit = 1bit(부호) + 15bit(정수부) + 16bit(소수부)

#### #1-2. 부동 소수점 (Floating Point)

    - 실수를 가수부 + 지수부로 표현 <br>
    e.g. 4.24e10 = 4.24 * 10^10
         4.24e-10 = 4.24 & 10^(-10)
    - 넓어진 표현범위
    32bit = 1bit(부호) + 8bit(지수부) + 23bit(가수부)
    - 오차 발생 가능성

### #2. 패리티 비트 & 해밍 코드

#### #2-1. 패리티 비트

- 의미 : 정보 전달과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트
- 기능 : 오류 검출
- 종류 : 짝수/홀수
  e.g. 짝수패리티일때 7비트 데이터가 1010001 -> '1'1010001로 만들어줌

#### #2-2. 해밍 코드

- 의미 : 데이터 전송시 1비트의 에러를 정정할 수 있는 자기 오류정정코드
- 기능 : 오류 검출 및 오류 수정
- n번째 패리티비트는 n비트에서 시작하여 n비트만큼 포함, n비트씩 건너뛴 비트들을 대상으로 패리티비트가 결정
  e.g. 데이터비트: 1011에 홀수 패리티비트를 적용하여 해밍코드로 변환 <br>
  (1) 2^n번째 자리에 패리티비트가 들어감 '','',1,'',0,1,1 <br>
  (2) 1비트는 1번째 비트부터 시작, 1번째 비트만 포함하고, 1비트씩 건너뛰므로 1,3,5,7번째 비트를 대상으로함. 1,3,5,7번째는 '',1,0,1 -> 홀수패리티인데 1이 2개이므로 1 <br>
  (3) 2비트는 2번째 비트부터 시작, 3번째 비트까지 포함하고, 2비트씩 건너뛰므로 2,3,6,7번째 비트를 대상으로함. 2,3,6,7번째는 '',1,1,1 -> 홀수패리티인데 1이 3개이므로 0 <br>
  (4) 4비트는 4번째부터시작, 7번째 비트까지 포함하고 4비트씩 건너뛰므로 4,5,6,7번재 비트를 대상으로함. 4,5,6,7번째는 '',0,1,1 -> 홀수패리티인데 1이 2개이므로 1 <br>
  (5) 패리티 비트는 101이고, ''에 순서대로 채워넣으면 해밍코드가 1011011 이 된다.

<br>
<br>

## CHAP05. ARM 프로세서

- 프로세서 : 중앙처리장치(CPU)를 의미. 하드웨어적/소프트웨어적 의미를 가짐.
- ARM (Advanced RISC-Reduced Insteuction Set Computing Machine)
  - RISC 아키텍처 기반으로 설계된 프로세서
  - 명령어 세트가 간단 -> 빠른 명령 실행
  - 하드웨어 구현이 단순 -> 낮은 전력 소모
- 장점
  - 저전력 고효율 -> 배터리 기반 기기에 강점 + 발열 적음
  - 단순한 설계 -> 하드웨어가 간단, 효과적인 파이프라인 구성가능
  - 확장성 -> 맞춤형 칩 설계, 통합이 원할
- 단점
  - 낮은 성능 -> x86 프로세서에 비해 낮은 성능
  - 호환성 -> 기존 x86용 소프트웨어를 실행하지 못함
  - 고성능 컴퓨팅의 제약 -> 서버, 고성능 워크로드에서는 부족할 수 있음

# ⚙️자료 구조 3주차

## Chap01. 트리 (Tree)

### #0. 그래프

- 자료구조 대분류

  1. 선형 자료구조
     - 데이터를 순서대로 나열한 구조.
     - 이전 데이터와 다음 데이터가 1:1로 구성 되어있음.
     - 예 : 배열, 연결리스트, 큐, 스택, ...
  2. 비선형 자료구조
     - 데이터가 계층적, 비순차적으로 연결된 구조.
     - 이전 데이터와 다음 데이터가 1:N, N:1, N:M으로 구성 되어있음.
     - 그래프, 트리, 힙, 해시, 집합, ...

- 그래프
  - 개념 : 정점(Node-컴퓨터과학, Vertex-수학)와 간선(Edge)으로 구성된 비선형 자료구조
    - 정점 : 그래프의 요소이며 특정 데이터값을 저장.
    - 간선 : 두 정점을 연결하는 선. (두정점은 인접되어 있음)
    - 방향성 : 간선의 방향
      - 무향 그래프 (사이클이 반드시 있음)
      - 유향 그래프
    - 차수 : 정점과 연결된 간선의 수
      - 유향 그래프는 진입 차수(in-degree)/진출 차수(out-degree)
    - 가중치 : 정점에서 정점으로 이동하는 거리값 혹은 비용. 가중치가 없는 경우는 연결여부로 표시(true, false)
    - 사이클 : 특정 정점으로 다시 돌아올 수 있는 간선이 있는 경우
  - 특징
    - 복수경로/방향성/사이클가 있(없)을 수도 있음.
    - 루트 노드 개념/계층 관계 없음 (트리에선 계층관계 존재)
  - 연결성에 따른 종류
    1. 완전 그래프 : 모든 정점쌍이 직접 연결된 그래프
    2. 연결 그래프 : 모든 정점쌍 사이에 경로가 존재. (경로에 다른 정점이 있는 경우도 경로로 봄)
    3. 비연결 그래프 : 일부 정점쌍 사이에 경로가 없음 (고립된 노드-어떤 간선도 연결되지 않은 노드가 있어도 비연결 그래프로 봄)
    4. 희소 그래프 : 정점 개수에 비해 간선의 수가 적은 그래프

### #1. 트리

- 개념

  - 노드(Node)와 간선(Edge)으로 이루어진 비선형 자료구조
  - 사이클이 없는 연결 그래프.
  - 루트노드(root node) : 트리의 시작노드
  - 리프노드(leaf node) : 자식이 없는 말단노드
  - 깊이 : 루트노드에서 특정노드까지 도달하는데 필요한 간선의 수 (루트노드의 깊이는 0)
  - 높이 : 특정노드에서 리프노드까지의 가장 긴 경로에 있는 간선의 수 (리프노드의 높이는 0)

- 특징

  - 모든 노드는 유일한 부모노드를 가짐.
  - 각 노드는 0개 이상의 자식노드를 가짐.
  - 노드가 n-1개일때 간선은 n-1개
  - 계층적 구조(부모-자식관계)를 가지며 하나의 루트노드를 기준으로 자식노드들이 아래로 뻗어나가는 형태

- 사용상황

  - 계층적 데이터 표현 e.g. 파일 시스템
  - 우선순위 큐 구현
  - 각종 트리 구현 (이진탐색트리, 최소신장트리, ...)

- 트리를 클래스와 내부 클래스(Node)로 구현한 자료구조 예시

  ```java
  public class Tree<T> {
      private Node<T> root;

      public Tree(T rootData) {
          root = new Node<T>();
          root.data = rootData;
          root.children = new ArrayList<Node<T>>();
      }

      public static class Node<T> {
          private T data;
          private Node<T> parent;
          private List<Node<T>> children;
      }
  }
  ```

- 트리를 생성하는 코드

  ```
   1
  / \
  2  3
  ```

  ```java
  // 트리 tree 생성
  // tree.root.data = 1
  // tree.root.children = 빈배열
  Tree(Integer) tree = new Tree<>(1);
  // 자식 노드 생성
  Tree.Node<Integer> node2 = new Tree.Node();
  node2.data = 2;
  node2.parent = tree.root;
  node2.chiledren = new ArrayList<>(); // 직접 할당하는 이유 : 생성자가 없기 때문 (기본생성자는 인자가 없음)
  Tree.Node<Integer> node3 = new Tree.Node();
  node2.data = 3;
  node2.parent = tree.root;
  node2.chiledren = new ArrayList<>();
  // 루트 노드의 자식리스트에 자식노드를 추가
  tree.root.children.add(node2);
  tree.root.children.add(node3);
  ```

- 트리 순회 방식

  ```
          1
      /      \
     2         3
   /   \    /    \
   4    5   6     7
  / \  / \   \   /
  8  9 10 11  13 14
  ```

  1. 전위 순회 (pre-order)

     - root -> 왼쪽자식 -> 오른쪽자식
     - 결과 : 1 -> 2 -> 4 -> 8 9 -> 5 -> 10 11 -> 3 -> 6 -> 13 -> 7 -> 14
     - 방식
       - 루트 출력, 자식노드로 이동
       - 이동한 자식노드가 새로운 루트인지 확인 = leaf노드 여부 확인
         1. leaf노드 O : 새로운 루트가 아님 -> 왼쪽자식노드로써 출력, 형제노드(오른쪽자식)를 출력
         2. leaf노드 X : 새로운 루트가 맞음 -> 루트노드로써 출력, 자식노드로 이동

  2. 중위 순회 (in-order) - 이진트리에서만 적용가능

     - 왼쪽자식 -> root -> 오른쪽자식
     - 결과 : 8 4 9 -> 2 -> 10 5 11 -> 1 -> 6 13 -> 3 -> 14 7
     - 방식
       - 왼쪽자식 출력, 부모노드로 이동
       - 이동한 부모노드 출력 후 자식노드 여부 확인
         1. 자식노드 O : 자식노드를 오른쪽 자식노드로써 출력
         2. 자식노드 X : 현재노드의 부모노드로 이동
       - 위 과정 반복

  3. 후위 순회 (post-order)

     - 왼쪽자식 -> 오른쪽자식 -> root
     - 결과 : 8 9 4 -> 10 11 5 -> 2 -> 13 6 -> 14 7 -> 3 -> 1
     - 방식
       - 왼쪽자식 출력, 부모노드로 올라가서 형제(자식)노드 여부 확인
         1. 있으면 형제노드(오른쪽자식)를 출력후 부모노드로 이동
         2. 없으면 부모노드로 이동
       - 이동한 부모노드 출력
       - 위 과정 반복

  4. 레벨 순회 (level-order)

     - BFS와 같은 방식으로 동작
     - 1 -> 2 3 -> 4 5 6 7 -> 8 9 10 11 13 14

# 10주차 🛜네트워크

## Chap05. Blocking I/O & Non-blocking I/O

### #0. 용어

#### I/O(Input/Output) 란?

- CPU가 직접 데이터를 주고받지 않고
  OS 커널이 디바이스(네트워크, 디스크 등)와 데이터를 주고받는 과정
- 작업 속도는 **CPU > I/O** 이므로, 기다림이 발생함 (병목 현상)
- Blocking과 Non-blocking은 I/O 대기 시간을 처리하는 것에 대한 개념

#### 스레드(Thread) 란?

- 실제로 코드를 실행하는 주체
- 스레드가 멈추는가, 계속 진행하는가는 Blocking과 Non-blocking을 구분하는 핵심 기준

#### 제어권(Control) 이란?

- CPU가 지금 어떤 코드를 실행할지 결정하는 권한
- 함수가 return하기 전까지 제어권이 없어 스레드는 멈춤 (Blocking)
- 함수가 즉시 return하면 제어권이 즉시 돌아와 다른 작업 가능 (Non-blocking)

#### 커널 버퍼 (OS I/O Buffer) 구조
- 커널 버퍼: 운영체제(OS) 커널 내부에 있는 임시 저장 공간(메모리) 으로,
I/O(입출력) 작업을 안전하고 효율적으로 처리하기 위해 사용하는 버퍼
- 읽기/쓰기는 실제 디바이스가 아닌 커널 버퍼와 데이터를 주고받는 과정
- 데이터가 준비되었는지 여부(Data Ready)를 커널이 판단
- Non-blocking은
  - 데이터가 준비된 경우 즉시 반환
  - 데이터가 준비되지 않은 경우 EAGAIN(지금은 데이터 없음) 즉시 반환

---

### #1. Blocking I/O

- 개념

  - 함수 호출 시 I/O 작업이 끝날 때까지 스레드가 멈춰서 기다리는 방식
  - 스레드는 함수가 return하기 전까지 제어권을 되찾지 못함

- 동작 원리

  1. 스레드가 I/O 호출 (e.g. `read()`)
  2. 커널이 I/O 준비 상태(Data Ready)를 확인
  3. 데이터가 준비되지 않았다면 스레드가 멈춤 (Blocking)
  4. 데이터가 준비되면 커널이 스레드를 다시 깨움
  5. 함수가 return하며 스레드가 제어권 가짐

- 특징

  - 구현이 단순하고 직관적
  - 소규모 프로그램에서 안정적
  - I/O가 느릴 경우 스레드가 쉽게 묶여 대기 상태로 오래 묶임
  - 대규모 연결 처리 시 스레드가 급증 -> 메모리 사용량 증가 및 컨텍스트 스위치 비용 증가 -> 성능 저하

- 사용 예시
  - 복잡한 병렬성이 필요없는 애플리케이션
  - 단순한 파일 읽기/쓰기
  - 스레드 수가 적은 소규모 네트워크 서버

---

### #2. Non-blocking I/O

- 개념

  - I/O가 준비되지 않아도 함수가 즉시 return하여(제어권 즉시 반환) 스레드가 멈추지 않음
  - 스레드는 제어권을 바로 되찾아 계속해서 다른 작업 수행 가능
  - Blocking I/O와 달리 스레드가 "기다리는 시간이 없음"

- 동작 원리

  1. 스레드가 I/O 호출 (e.g. `read()`에 NONBLOCK 플래그 설정)
  2. 커널이 I/O 준비 상태(Data Ready)를 확인
  3. 데이터가 준비되지 않았다면 EAGAIN과 제어권을 반환
  4. 스레드는 기다리지 않고 다른 작업 수행
  5. I/O 결과 처리 방식에 따라 나뉨
     - 5.1 Non-blocking + Synchronous (Polling 모델): 스레드가 반복적으로 I/O 호출을 재시도하여 데이터 준비 여부를 확인
     - 5.2 Non-blocking + Asynchronous (이벤트 기반 모델): I/O 완료 시점에 커널 또는 런타임이 콜백/이벤트 등으로 스레드에게 알려줌

- EAGAIN

  - 요청한 I/O 작업을 지금 당장 수행할 수 없으니 **다시 시도해(AGAIN)**라는 의미의 커널 반환 코드 (errno: 11)
  - **Polling 모델(Non-blocking + Sync)**에서만 의미 있음
(이벤트 기반 Async 모델에서는 스레드가 직접 확인하지 않으므로 EAGAIN을 받을 일이 없음)

- 사용 예시
  - 고성능 네트워크 서버 (수천-수만 클라이언트)
  - 웹 서버, 채팅 서버, 게임 서버 등
  - Node.js, epoll 기반 서버, Go runtime 등 대부분의 현대 서버 모델

---

### 퀴즈

#### 1. Non-blocking I/O에 대한 설명으로 옳지 않은 것은?

1. I/O가 준비되지 않으면 즉시 반환한다.
2. 스레드는 제어권을 계속 유지하며 다른 작업을 수행할 수 있다.
3. 커널은 준비되지 않은 I/O에 대해 EAGAIN을 반환하기도 한다.
4. Non-blocking I/O는 반드시 Asynchronous 방식으로 결과를 전달해야 한다.
5. Non-blocking I/O는 Blocking I/O보다 고성능 서버 구조에 적합하다.

- 정답: 4

#### 2. 다음 개념들을 조합한 모델로 올바른 설명을 고르시오

1. Blocking + Sync = 스레드는 직접 결과를 기다린다.
2. Blocking + Async = 스레드가 멈추지만 결과를 polling한다.
3. Non-blocking + Sync = I/O 완료 알림을 비동기로 전달한다.
4. Non-blocking + Async = 스레드는 기다리며 콜백을 실행한다.
5. Async = Non-blocking이라는 뜻이다.

- 정답: 2

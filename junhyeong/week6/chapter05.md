# 🖲️운영체제 6주차

## Chap15. 파일 시스템

### #0. 파일의 개념

#### 파일 종류

- 폴더(디렉터리) : 하위 파일/디렉터리 정보를 관리하는 파일
- 실행 파일 : 운영체제가 메모리로 가져와 CPU를 이용하여 작업하는 파일
- 데이터 파일 : 실행 파일 작업에 필요한 데이터를 모아놓은 파일
- 링크 파일 : 다른 파일/디렉터리의 위치를 가리키는 파일
- 장치 파일 : 하드웨어와 운영체제 간의 연결을 나타내는 파일 e.g. /dev

#### 파일 이름

- 형태 : "파일이름.확장자"
- 파일명에는 마침표(.) 여러개가 가능하며 마지막에 찍힌 다음 글자를 확장자로 인식
- 파일명은 주로 **영문자 숫자 - \_ .** 를 사용

#### 파일 속성

- 개념

  - 파일의 실제 데이터(content) 외에, 파일의 상태/성격/관리목적 등 다양한 정보를 담은 메타데이터
  - 운영체제의 파일 관련 동작 수행에 활용됨
  - 모든 파일에 공통으로 적용되는 파일 속성은 **파일 테이블**에 위치
  - 해당 파일에 필요한 파일 속성은 **파일 헤더**에 위치

- 종류

  1. 읽기 전용 : 읽기 O, 수정/삭제 X
  2. 숨김 : 일반 탐색기로 보이지 않게 숨겨짐
  3. 시스템 : 운영체제 동작에 반드시 필요한 파일 (보호 목적)
  4. 아카이브 : 백업/보관 목적으로 활용됨
  5. 타임스탬프 : 시간 정보 기록 (생성일/최종수정일/마지막접근일 등)

#### 파일 헤더

- 파일의 버전, 크기, 특수 정보 등 응용 프로그램에 필요한 정보가 담김
- 파일의 맨 앞에 위치

#### 블록

- 개념

  - 저장장치의 기본 단위 (가장 작은 단위)
  - 파일의 구성 요소(데이터, 주소 등)가 여러 블록에 나뉘어 저장될 수 있음 -> 하나의 파일 주소가 여러 블록 번호를 가질 수 있음

- 종류

  - 일반 데이터 블록 : 파일의 데이터 자체가 저장됨
  - 인덱스(포인터) 블록 : 파일의 주소가 저장됨
  - 블록에는 데이터 자체, 파일의 주소가 저장됨

- 특징
  - 블록의 크기는 일반적으로 4KB, 8KB 등
  - 인덱스 블록의 예시 : FAT 테이블, inode 블록의 포인터

#### 파일 테이블

- 개념 : 파일 시스템의 메타데이터를 모아놓은 자료구조
- 특징
  - 각 파일이 어느 블록(저장장치)에 저장되어 있는지에 대한 정보를 저장
  - 파일 하나에 여러 블록 정보, 파일 속성, 링크 정보 등을 저장
  - 운영체제가 파일 열기/닫기 시 파일 테이블을 활용하여 블록 위치/속성/권한을 관리함

---

### #1. 파일 시스템의 개요

#### 파일 시스템

- 개념

  - 컴퓨터에서 데이터(파일/자료)를 효율적으로 검색/저장/조작할 수 있도록 조직화하는 체계
  - 저장매체의 데이터를 효율적으로 관리하기 위해 구현한 **운영체제** 커널의 **하위 시스템**
  - 파일 시스템에는 다양한 종류(포맷)가 존재
    - 포맷은 용도(속도/호환성/보안)에 따라 저장/할당/백업 방식 다름
    - e.g. FAT, NTFS, ext, HFS, APFS, ...

- 주요 기능

  1. 파일/디렉터리 구성 및 관리
  2. 접근 방법 제공 : 순차, 직접, 색인 방식
  3. 무결성 보장 : 파일 내용을 손상으로 부터 보호
  4. 백업/복구 및 암호화
  5. 다양한 저장매체와 호환하는 인터페이스 제공

- 구성 요소 : **파일**, **폴더**(=디렉터리), **블록**, **메타데이터**(파일이름, 경로, 크기, 권한 등), ...

- 특징
  - 계층적 구조 : 폴더(디렉터리)를 포함하는 트리 구조. 데이터 접근이 빠르고 데이터 손실 위험을 낮춰줌
  - 파일/디렉터리의 메타데이터/접근권한까지 관리
  - 파일이름과 경로 체계를 통한 빠르고 편리한 방식
  - 디스크 공간 효율성을 제공 : 단편화 방지 및 공간 최적화

#### 파일 관리자의 개념

- 개념 : 파일/디렉터리를 쉽고 체계적으로 탐색 및 관리할 수 있도록 해주는 소프트웨어 도구 (프로그램)

- 특징
  - 파일 시스템의 내부 구조와 API를 사용자 친화적인 방식(GUI, 아이콘 등)으로 제공
  - 파일/디렉터리의 주요 작업 지원 (생성, 삭제, 이동, 복사, 이름 변경 등)
  - 다양한 저장 매체와의 연결 및 관리 기능도 지원

---

### #2. 저장장치 관리 기법

#### 파티션

- 개념 : 저장장치를 2개 이상의 묶음으로 나누는 것
- 즉, 디스크를 논리적으로 분할하는 것

#### 포맷

- 개념
  - 저장장치의 파일 시스템을 초기화하는 작업
  - 파일 테이블이 새로 생성(원래 있었다면 초기화)됨
- 종류
  - 빠른 포맷 : 데이터가 아닌 파일 테이블만 초기화 -> 실제 파일 데이터(음악, 영상 등)는 남아 있어서 복구 가능함 + 파일 시스템에서는 인식 안됨
  - 느린 포맷
    - 파일의 구조 및 블록의 모든 데이터를 초기화
    - 파일의 구조 = 파일 테이블 + 메타데이터 + 디렉터리 + 디스크 블록, ...
- 블록의 크기 지정 가능
  - 블록 크기가 큰 경우 : 적은 주소로 많은 데이터 관리 가능 -> 단편화 발생
  - 블록 크기가 작은 경우 : 많은 양의 블록 주소 필요

#### 마운트

- 개념

  - 저장장치에 있는 파일 시스템을 디렉터리 트리의 특정 위치에 연결하는 작업
  - 해당 파일 시스템의 파일/폴더에 접근할 수 있게 됨
  - 즉, 파일 시스템 접근의 출발점

- 특징

  - 마운트 시 해당 저장 장치의 파일에 접근/생성/수정이 가능해짐
  - 언마운트를 통해 저장장치를 안전하게 분리 가능

- 활용 예시
  - 리눅스 계열에서는 실제 장치(/dev/sda1, /dev/sda2 등)를 특정 디렉터리(/mnt/usb, /home 등)에 연결해야 함
  - 윈도우에서는 USB 삽입 시 드라이브로 자동 마운트 해줌

#### 조각 모음과 컴팩션

- 조각 모음 : 여러 파일의 분산된 블록을 재배치하여 연속적으로 만드는 작업
- 컴팩션 : 메인 메모리의 빈 공간을 한 곳에 모르며 기존 프로세스를 연속적으로 배치하는 작업

| 구분      | 컴팩션                                      | 조각 모음                                   |
| :-------- | :------------------------------------------ | :------------------------------------------ |
| 적용대상  | 주기억장치(RAM)                             | 보조저장장치(HDD/SSD)                       |
| 목적      | 프로세스 연속적 배치, 메모리 할당 실패 방지 | 파일의 연속적 배치 및 디스크 읽기 속도 향상 |
| 원인      | 외부 단편화                                 | 파일 저장/삭제로 인한 블록 분산             |
| 동작 방식 | 메인 메모리의 빈 공간을 한곳을 모음         | 여러 파일의 분산된 조각을 한곳에 재배치     |
| 결과      | 큰 프로세스 적재 가능 및 단편화 해소        | 디스크 입출력 속도 증가 (성능 개선)         |

---

### #3. 파일 접근 방식

#### 개념

- 운영체제가 파일 내부 데이터를 읽고 쓰는 논리적인 절차
- 파일의 어느 위치에 어떻게 접근할지 정의하는 방법

#### 종류

1. **순차 접근 (Sequential Access)**

   - 개념
     - 파일을 처음부터 끝까지 순서대로 읽거나 쓰는 방식
     - 구현이 간단하며 연속적인 데이터에 적합함 + 대용량 파일 처리에 효율적
   - 특징
     1. 읽기 시에는 포인터(현재 위치)를 자동으로 이동시킴
     2. 특정 위치로 점프가 불가능 -> 검색 속도가 느림
     3. 데이터를 덮어쓰거나 수정하기 보단 전체를 다시 작성하는 형태가 많음
   - 예시
     - 텍스트 파일, 로그 파일, 오디오/비디오 스트리밍 등
     - 실생활 예시 : 테이프 저장장치에서 사용

2. **직접 접근 (Direct Access, Random Access)**

   - 개념
     - 파일의 특정 블록으로 직접 접근이 가능한 방식
     - 파일을 블록 단위(혹은 레코드)로 구성하고, 임의의 블록을 직접 읽기/쓰기 가능
     - 파일의 구조(저장된 위치나 주소)를 알고 있어야 함
   - 특징
     1. 빠른 검색, 수정이 가능
     2. 순차/비순차 모두 지원
     3. 블록 관리가 복잡함 -> 주소 관리, 단편화 문제
   - 예시
     - 데이터베이스(DB), 실행 파일, 이미지/영상 파일 등
     - 실생활 예시 : 플래시 메모리, 하드디스크, SSD 등

3. **인덱스 접근 (Indexed Access)**

   - 개념
     - 파일의 데이터 위치를 빠르게 찾기 위해 인덱스 테이블을 별도로 관리하는 방식
     - 인덱스 테이블은 키 값 -> 블록 주소의 매핑을 가짐
     - 데이터 파일과 별개의 인덱스 블록 존재
   - 특징

     1. 검색 속도 매우 빠름 : 인덱스 파일을 통해 특정 레코드의 위치를 빠르게 찾으므로
     2. 대용량 데이터에서도 효율적
     3. 인덱스 테이블을 관리할 추가 공간 필요 + 인덱스 갱신 비용 발생 (파일 수정 시 마다)

   - 예시
     - 데이터베이스의 B+ 트리 인덱스
     - 리눅스/유닉스의 i-node 구조
     - 윈도우의 FAT 테이블

#### 표 요약

| 접근 방식   | 특징                          | 장점      | 단점             | 예시         |
| :---------- | :---------------------------- | :-------- | :--------------- | :----------- |
| 순차 접근   | 처음부터 끝까지 순서대로 접근 | 구현 간단 | 임의 접근 불가   | 텍스트, 로그 |
| 직접 접근   | 특정 블록에 바로 접근         | 빠른 검색 | 블록 관리 복잡   | 데이터베이스 |
| 인덱스 접근 | 인덱스 테이블 통해 탐색       | 매우 빠름 | 인덱스 공간 발생 | FAT, i-node  |

---

### #4. 디렉터리 및 디스크 구조

#### 디렉터리 구조 (Directory Structure)

- 개념
  - 파일을 체계적으로 관리하기 위한 논리적 그룹
  - 파일 시스템의 트리 구조, 주소록 역할을 함
- 종류
  1. **단일 수준 디렉터리 (Single-Level Directory)**
     - 개념 : 모든 파일이 하나의 디렉터리에 존재
     - 특징
       - 단순하고 구현이 쉬움
       - 파일 수가 많아지면 관리가 어려워짐 + 이름 충돌 발생 (이름 중복이 불가하므로)
       - 예시 : MS-DOS, 옛날 시스템
  2. **이중 수준 디렉터리 (Two-Structured Directory)**
     - 개념 : 사용자별 하위 디렉터리 존재 (User1, User2, ...)
     - 특징
       - 사용자 간 파일 이름 중복 가능
       - 사용자 간 파일 공유가 불편함
       - 예시 : 초창기 다중 사용자 OS
  3. **트리 구조 디렉터리 (Tree-Structured Diectory)**
     - 개념 : 루트 디렉터리를 중심으로 하위 디렉터리가 트리 형태로 구성됨
     - 특징
       - 현재 거의 모든 OS가 사용하는 구조
       - 파일 탐색/관리에 용이
       - 트리 탐색 시 경로 계산이 필요
       - 예시
         ```
         / (root)
         ├── home/
         │   ├── user1/
         │   │   ├── todo.txt
         │   │   └── study.docx
         │   └── user2/
         └── etc/
         ```
  4. **비순환 그래프 디렉터리 (Acyclic Graph Directory)**
  - 개념
    - 여러 경로에서 같은 파일을 공유 가능
    - 하드 링크(hard link) 혹은 심볼릭 링크(symbolic link)로 형태로 구현
  - 특징
    - 파일 공유 용이
    - 삭제/수정 시 참조 무결성 관리 필요
    - 예시 : 리눅스/유닉스의 하드 링크, 심볼릭 링크
  - 용어
    - 하드 링크
      - 개념
        - 하나의 파일(데이터 블록)에 여러 디렉터리 엔트리(파일 이름)을 생성
        - 원본 파일과 하드 링크는 같은 inode(실제 데이터 위치 정보)를 공유
      - 특징
        - 같은 파일 시스템(파티션) 내에서만 생성 가능
        - 파일만 대상으로 가능 (디렉터리는 제한적)
        - 원본 파일을 삭제해도, 하드링크가 하나도 있으면 데이터는 지워지지 않음
        - 데이터를 공유함
    - 심볼릭 링크
      - 개념 : 링크 대상(파일/디렉터리)의 경로를 저장해두는 파일
      - 특징
        - 실제 데이터 블록이 아닌, 참조 정보만 가짐
        - 파일, 디렉터리 모두 링크 대상으로 가능
        - 원본 삭제 시, 죽은 링크(broken/dangling)이 됨
        - 단순 경로만 저장하므로 크기는 작은편

#### 디스크 할당 방식 (Disk Allocation Method)

- 개념 : 파일 데이터를 디스크 블록에 저장하는 물리적 방식
- 종류

  1. **연속 할당 (Contiguous Allocation)**

     - 개념 : 파일이 연속된 블록들에 저장
     - 특징
       - 순차 접근 빠름
       - 외부 단편화 발생
     - 예시

       - CD-ROM, ISO 이미지

       ```
       [File A] -> Block 1, 2, 3, 4

       ```

  2. **연결 할당 (Linked Alloaction)**

     - 개념 : 각 블록이 다음 블록 주소 포인터를 가지고 연결되는 방식
     - 특징
       - 단편화 해결, 공간 효율적
       - 중간 블록 손상 시 전체 파일 접근 불가
     - 예시

       - 윈도우의 FAT(File Allocation Table) 구조

       ```
       Block 1 → Block 5 → Block 9 → ...

       ```

  3. **인덱스 할당 (Indexed Allocation)**

  - 개념 : 파일마다 인덱스 블록을 하나 두고, 그 안에 실제 데이터 블록들의 주소를 저장
  - 특징

    - 임의 접근 빠름
    - 단편화 없음
    - 인덱스 블록이 커질 경우 오버헤드 발생
    - 예시

      - 유닉스의 i-node 구조

      ```
      A.txt = "Hello World This is Ureca!"
          [Index Block]
      ├──> [Data Block 1] = "Hello"
      ├──> [Data Block 5] = "World"
      ├──> [Data Block 9] = "This is"
      ├──> [Data Block 10] = "Ureca!"
      └──> ...
      ```

      ```
      [Index Block] → [Data Block 1, 5, 9, 10, ...]
      ```

- 대표적인 파일 시스템 구조
  - FAT : 연결 할당 -> 단순 구조, 포인터 기반 연결
  - i-node : 인덱스 할당 -> 다단계 인덱싱, 대용량 파일에 효율적
  - NTFS : 인덱스 + 저널링 -> 메타데이터 보호/복구 기능
  - EXT4 : 인덱스 + 저널링 -> extents 기반 연속 블록 관리

---

### 퀴즈

#### 1번.

- 우리는 디스크 할당 방식의 연결 할당/연결 할당/인덱스 할당이 있다는 것을 알았으며
- 접근 방식에는 순차 접근/직접 접근/인덱스 접근이 있다는 것을 알았습니다.
- 아래에서 권장되지 않는 조합을 고르세요.

1. 연속 할당 + 순차 접근
2. 연속 할당 + 직접 접근
3. 인덱스 할당 + 직접 접근
4. 연결 할당 + 직접 접근

- 4번

#### 2번. 빠른 포맷과 느린 포맷의 차이점

- 빠른 포맷은 실제 데이터를 삭제하지 않지만
- 느린 포맷은 실제 데이터와 파일 테이블에 대한 정보까지 모두 삭제
